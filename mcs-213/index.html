<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Primary Meta Tags -->
  <title>IGNOU MCA Course Notes | MCS213 Software Engineering</title>
  <meta name="title" content="IGNOU MCA Course Notes | MCS213 Software Engineering">
  <meta name="description" content="Free and easy-to-understand IGNOU MCA course notes for MCS213 Software Engineering. Useful for exams, last-minute revision, and concept clarity.">
  <meta name="keywords" content="IGNOU MCA, MCS213, Software Engineering, IGNOU Notes, MCA Notes, IGNOU Software Engineering, MCS213 Notes">
  <meta name="author" content="IGNOU MCA Student Notes">

  <!-- Search Engine -->
  <meta name="robots" content="index, follow">

  <!-- Open Graph / Social Media -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="IGNOU MCA Course Notes | MCS213 Software Engineering">
  <meta property="og:description" content="Exam-oriented IGNOU MCA notes for MCS213 Software Engineering with diagrams and examples.">
  <meta property="og:site_name" content="IGNOU MCA Notes">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="IGNOU MCA Course Notes | MCS213 Software Engineering">
  <meta name="twitter:description" content="Simple and exam-focused IGNOU MCA notes for MCS213 Software Engineering.">

  <!-- Pico CSS -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css"
  >
</head>

<body>
<h1 id="unit-1-software-engineering-and-its-models-">Unit 1: Software Engineering and Its Models ğŸ“š</h1>
<p>Let me teach you Unit 1 in simple language!</p>
<h2 id="what-is-software-engineering-">What is Software Engineering?</h2>
<p>Think of building software like building a house. You can&#39;t just start randomly putting bricks together - you need a plan, proper tools, and a step-by-step process. That&#39;s exactly what Software Engineering is![1]</p>
<p><strong>Simple Definition</strong>: Software Engineering = Using organized methods to build, test, and maintain software (not just writing random code!)</p>
<h3 id="programming-vs-software-engineering">Programming vs Software Engineering</h3>
<ul>
<li><strong>Programming</strong> = Just writing code</li>
<li><strong>Software Engineering</strong> = Planning + Designing + Coding + Testing + Documentation + Maintenance[1]</li>
</ul>
<h2 id="how-software-engineering-evolved">How Software Engineering Evolved</h2>
<h3 id="1960s-baby-steps-">1960s - Baby Steps ğŸ‘¶</h3>
<ul>
<li>People wrote simple programs in machine code</li>
<li>No proper process, just individual programmers working alone[1]</li>
</ul>
<h3 id="1970s-80s-growing-up-">1970s-80s - Growing Up ğŸ“ˆ</h3>
<ul>
<li>Bigger teams started working together</li>
<li>Languages like PASCAL and COBOL made coding easier</li>
<li>Quality assurance concepts were introduced[1]</li>
</ul>
<h3 id="1990s-professional-era-">1990s - Professional Era ğŸ’¼</h3>
<ul>
<li>Software companies (software houses) were born</li>
<li>Software became a <strong>product</strong> to sell</li>
<li>Tools like CASE (Computer Aided Software Engineering) made development faster[1]</li>
</ul>
<h3 id="today-quality-focus-">Today - Quality Focus â­</h3>
<ul>
<li>Focus on reliability, reusability, and quality</li>
<li>Software creates the most valuable product: <strong>Information</strong>[1]</li>
</ul>
<h2 id="software-development-models">Software Development Models</h2>
<p>Think of these as different recipes for making software:</p>
<h3 id="1-build-and-fix-model-">1. <strong>Build and Fix Model</strong> ğŸ”¨</h3>
<p>The simplest (and worst!) approach:</p>
<ul>
<li>Step 1: Write code</li>
<li>Step 2: Fix problems</li>
<li>Step 3: Keep fixing until customer is happy</li>
</ul>
<p><strong>Problem</strong>: No planning, chaotic![1]</p>
<h3 id="2-waterfall-model-">2. <strong>Waterfall Model</strong> ğŸŒŠ</h3>
<p>Like a waterfall flowing down step by step:</p>
<pre><code>Requirements â†’ <span class="hljs-built_in">Design</span> â†’ Coding â†’ Testing â†’ Maintenance
</code></pre><p><strong>Good</strong>: Organized and systematic
<strong>Bad</strong>: Can&#39;t go back easily if requirements change[1]</p>
<h3 id="3-iterative-enhancement-model-">3. <strong>Iterative Enhancement Model</strong> ğŸ”„</h3>
<p>Build software in small versions:</p>
<ul>
<li>Version 1: Basic features</li>
<li>Version 2: Add more features</li>
<li>Version 3: Even more features...</li>
</ul>
<p><strong>Good</strong>: Users get something to use quickly
<strong>Bad</strong>: Might never finish if iterations keep going![1]</p>
<h3 id="4-prototyping-model-">4. <strong>Prototyping Model</strong> ğŸ¨</h3>
<p>Build a &quot;demo version&quot; first:</p>
<ul>
<li>Make a working sample (prototype)</li>
<li>Show it to customer</li>
<li>Get feedback</li>
<li>Build the real product</li>
</ul>
<p><strong>Good</strong>: Customer knows what they&#39;re getting
<strong>Bad</strong>: Takes extra time to build prototype[1]</p>
<h3 id="5-spiral-model-">5. <strong>Spiral Model</strong> ğŸŒ€</h3>
<p>Combines all good ideas in a spiral loop:</p>
<ol>
<li>Set objectives</li>
<li>Identify risks</li>
<li>Develop and test</li>
<li>Plan next iteration</li>
</ol>
<p><strong>Good</strong>: Handles risks well, very flexible
<strong>Bad</strong>: Complex to manage[1]</p>
<h2 id="capability-maturity-model-cmm-">Capability Maturity Model (CMM) ğŸ¯</h2>
<p>Think of this as &quot;levels&quot; in a video game for software companies:</p>
<h3 id="level-1-initial-chaos-">Level 1 - <strong>Initial</strong> (Chaos!)</h3>
<ul>
<li>No proper process</li>
<li>Success depends on individual heroes</li>
<li>Most companies start here[1]</li>
</ul>
<h3 id="level-2-repeatable-">Level 2 - <strong>Repeatable</strong></h3>
<ul>
<li>Basic project management</li>
<li>Can repeat successful projects</li>
<li>Learning from experience[1]</li>
</ul>
<h3 id="level-3-defined-">Level 3 - <strong>Defined</strong></h3>
<ul>
<li>Everything is documented</li>
<li>Standard processes for everyone</li>
<li>Training provided to staff[1]</li>
</ul>
<h3 id="level-4-managed-">Level 4 - <strong>Managed</strong></h3>
<ul>
<li>Measuring everything with numbers</li>
<li>Quality is predictable</li>
<li>Data-driven decisions[1]</li>
</ul>
<h3 id="level-5-optimizing-perfect-">Level 5 - <strong>Optimizing</strong> (Perfect!)</h3>
<ul>
<li>Continuous improvement</li>
<li>Always looking for better ways</li>
<li>Very few companies reach here[1]</li>
</ul>
<h2 id="software-development-life-cycle-sdlc-">Software Development Life Cycle (SDLC) ğŸ”„</h2>
<p>The 5 main phases:</p>
<h3 id="1-requirements-analysis-">1. <strong>Requirements Analysis</strong> ğŸ“</h3>
<ul>
<li><strong>What</strong>: Understanding what customer wants</li>
<li><strong>Output</strong>: SRS (Software Requirements Specification) document</li>
<li>Like taking detailed order at a restaurant[1]</li>
</ul>
<h3 id="2-design-">2. <strong>Design</strong> ğŸ¨</h3>
<ul>
<li><strong>What</strong>: Creating the blueprint</li>
<li><strong>Output</strong>: SDD (Software Design Document)</li>
<li>Like an architect drawing house plans[1]</li>
</ul>
<h3 id="3-coding-">3. <strong>Coding</strong> ğŸ’»</h3>
<ul>
<li><strong>What</strong>: Writing actual code</li>
<li><strong>Input</strong>: Design document</li>
<li><strong>Output</strong>: Working program</li>
<li>Like builders constructing the house[1]</li>
</ul>
<h3 id="4-testing-">4. <strong>Testing</strong> ğŸ§ª</h3>
<ul>
<li><strong>What</strong>: Finding and fixing errors</li>
<li><strong>Types</strong>: <ul>
<li>White box (checking internal logic)</li>
<li>Black box (checking functionality)</li>
</ul>
</li>
<li>Like quality inspection before delivery[1]</li>
</ul>
<h3 id="5-maintenance-">5. <strong>Maintenance</strong> ğŸ”§</h3>
<ul>
<li><strong>What</strong>: Fixing bugs and adding features after release</li>
<li><strong>Costs</strong>: 50-80% of total project cost!</li>
<li>Like servicing your car regularly[1]</li>
</ul>
<h2 id="key-takeaways-">Key Takeaways ğŸ“</h2>
<ol>
<li><p><strong>Software is different</strong> from physical products - it can be changed easily but can never be 100% error-free[1]</p>
</li>
<li><p><strong>Choose the right model</strong> - Different projects need different approaches[1]</p>
</li>
<li><p><strong>Testing is crucial</strong> - You can never test too much![1]</p>
</li>
<li><p><strong>Maintenance is expensive</strong> - Most money is spent AFTER the software is built[1]</p>
</li>
<li><p><strong>Quality matters</strong> - Better to spend time designing well than fixing later[1]</p>
</li>
</ol>
<hr>
<br />
<p>Now let me teach you <strong>Unit 2</strong> and <strong>Unit 3</strong> in simple language! ğŸ“</p>
<hr>
<h1 id="unit-2-principles-of-software-requirements-analysis-">Unit 2: Principles of Software Requirements Analysis ğŸ“‹</h1>
<h2 id="what-are-requirements-">What are Requirements?</h2>
<p>Think of a restaurant order. A customer says &quot;I want a pizza with cheese, pepperoni, and no onions.&quot; That&#39;s a <strong>requirement</strong>! In software, requirements are what the customer wants the software to do.[1]</p>
<p><strong>Simple Definition</strong>: Requirements = &quot;What the system should do?&quot;[1]</p>
<h2 id="types-of-requirements">Types of Requirements</h2>
<h3 id="based-on-priority-">Based on Priority ğŸ¯</h3>
<ol>
<li><strong>Must Have</strong> - Absolutely essential (like ordering pizza with dough)</li>
<li><strong>Nice to Have</strong> - Highly desirable but optional (like extra cheese)</li>
<li><strong>Could Have</strong> - Optional features (like premium toppings)[1]</li>
</ol>
<h3 id="based-on-what-they-describe-">Based on What They Describe ğŸ“</h3>
<ol>
<li><p><strong>Functional Requirements</strong></p>
<ul>
<li>What the system does</li>
<li>Input/output formats</li>
<li>Storage structure</li>
<li>Speed and timing</li>
<li><strong>Example</strong>: &quot;System should process orders within 2 seconds&quot;[1]</li>
</ul>
</li>
<li><p><strong>Non-Functional Requirements</strong></p>
<ul>
<li>How well the system does it</li>
<li>Usability, efficiency, performance</li>
<li>Reliability, portability</li>
<li><strong>Example</strong>: &quot;System should be user-friendly and run on Windows &amp; Mac&quot;[1]</li>
</ul>
</li>
</ol>
<h2 id="software-requirements-specification-srs-">Software Requirements Specification (SRS) ğŸ“„</h2>
<p>This is the <strong>blueprint document</strong> that explains everything about the system.</p>
<h3 id="what-does-srs-contain-1-">What does SRS contain?[1]</h3>
<ol>
<li><p><strong>Introduction</strong></p>
<ul>
<li>Purpose</li>
<li>Scope</li>
<li>Definitions and abbreviations</li>
</ul>
</li>
<li><p><strong>Overall Description</strong></p>
<ul>
<li>What the product is</li>
<li>What functions it has</li>
<li>Who will use it</li>
</ul>
</li>
<li><p><strong>Specific Requirements</strong></p>
<ul>
<li>Exact details</li>
<li>External interfaces</li>
<li>Performance needs</li>
<li>Database requirements</li>
</ul>
</li>
<li><p><strong>Supporting Information</strong></p>
<ul>
<li>Examples</li>
<li>Additional details[1]</li>
</ul>
</li>
</ol>
<h2 id="how-to-gather-requirements-">How to Gather Requirements? ğŸ”</h2>
<h3 id="4-main-tools-">4 Main Tools:</h3>
<ol>
<li><p><strong>Record Review</strong> ğŸ“š</p>
<ul>
<li>Check existing documents</li>
<li>Look at procedures and manuals</li>
<li>See how current system works</li>
<li><strong>Time</strong>: Takes longer[1]</li>
</ul>
</li>
<li><p><strong>On-Site Observation</strong> ğŸ‘€</p>
<ul>
<li>Visit the actual location</li>
<li>Watch people work</li>
<li>Find current problems</li>
<li><strong>Best for</strong>: Real-world systems[1]</li>
</ul>
</li>
<li><p><strong>Interview</strong> ğŸ¤</p>
<ul>
<li>Talk directly to users</li>
<li>Ask what they need</li>
<li>Understand their jobs</li>
<li><strong>Requires</strong>: Good conversation skills[1]</li>
</ul>
</li>
<li><p><strong>Questionnaire</strong> ğŸ“‹</p>
<ul>
<li>Send written questions</li>
<li>Get many responses at once</li>
<li>People have time to think</li>
<li><strong>Best for</strong>: Large groups[1]</li>
</ul>
</li>
</ol>
<h2 id="common-problems-in-requirements-analysis-">Common Problems in Requirements Analysis âš ï¸</h2>
<ol>
<li><strong>Incomplete Requirements</strong> - Can&#39;t capture everything at the start[1]</li>
<li><strong>Changing Requirements</strong> - New needs keep appearing during development[1]</li>
<li><strong>Communication Gap</strong> - Developers and users speak different &quot;languages&quot;[1]</li>
<li><strong>Time Pressure</strong> - Too little time to gather requirements properly[1]</li>
<li><strong>Different Backgrounds</strong> - Users and developers have different perspectives[1]</li>
</ol>
<hr>
<h2 id="system-modeling-showing-how-system-works-">System Modeling - Showing How System Works ğŸ¨</h2>
<p>Before building the system, we create <strong>models</strong> (drawings) to show what it will look like.</p>
<h3 id="two-types-of-models-">Two Types of Models:</h3>
<h3 id="1-environmental-model-">1. <strong>Environmental Model</strong> ğŸŒ</h3>
<ul>
<li>Shows the system and its surroundings</li>
<li>What comes in? What goes out?</li>
<li>Which external systems does it connect to?</li>
</ul>
<p><strong>Example</strong>: A College System connects to:</p>
<ul>
<li>University</li>
<li>National Educational System</li>
<li>Students</li>
<li>Teachers[1]</li>
</ul>
<h3 id="2-behavioral-model-">2. <strong>Behavioral Model</strong> ğŸƒ</h3>
<ul>
<li>Shows what the system does</li>
<li>How does data move inside?</li>
<li>What operations happen?</li>
</ul>
<hr>
<h2 id="data-flow-diagrams-dfd-drawing-data-movement-">Data Flow Diagrams (DFD) - Drawing Data Movement ğŸ“Š</h2>
<p>This is like drawing arrows showing where information flows in the system.[1]</p>
<h3 id="simple-example-student-registration-system-">Simple Example - Student Registration System:</h3>
<pre><code>Student â†’ <span class="hljs-keyword">Provide</span> Details â†’ Register Student â†’ Database
         â†“
      Database â†’ Generate Receipt â†’ <span class="hljs-built_in">Print</span> â†’ Student
</code></pre><h3 id="dfd-symbols-">DFD Symbols: ğŸ”·</h3>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Circle/Bubble</strong></td>
<td>A process (something that happens)</td>
</tr>
<tr>
<td><strong>Arrow</strong></td>
<td>Data flowing</td>
</tr>
<tr>
<td><strong>Rectangle</strong></td>
<td>External entity (person or system)</td>
</tr>
<tr>
<td><strong>Open Rectangle</strong></td>
<td>Data store (like a database)</td>
<td>[1]</td>
</tr>
</tbody>
</table>
<h3 id="levels-of-dfd-">Levels of DFD: ğŸ“ˆ</h3>
<ul>
<li><strong>Level 0 (Context Diagram)</strong> - Entire system as one box, shows only main inputs/outputs</li>
<li><strong>Level 1</strong> - Breaks system into main processes</li>
<li><strong>Level 2</strong> - More detailed processes</li>
<li>And so on... (more details as we go deeper)[1]</li>
</ul>
<h3 id="example-production-management-system-1-">Example: Production Management System[1]</h3>
<pre><code>Sales â†’ Production Planning System â†’ Material Management
<span class="hljs-keyword">Order</span> <span class="hljs-title">â†’ (DFD</span> Process)            â†’ Inventory

Manager â†’ Product Database â†’ Finished Goods
</code></pre><hr>
<h2 id="data-dictionary-">Data Dictionary ğŸ“š</h2>
<p>A <strong>detailed list</strong> explaining every piece of data in the system.</p>
<p>Think of it like a dictionary for the system:</p>
<p><strong>Example - Payroll System:</strong></p>
<pre><code>PAYROLL = Employee <span class="hljs-keyword">Name</span> + Employee ID + Basic Salary + Allowances

Employee <span class="hljs-keyword">Name</span> = First <span class="hljs-keyword">Name</span> + Last <span class="hljs-keyword">Name</span>
Employee ID = Unique <span class="hljs-keyword">Number</span> (<span class="hljs-number">001</span>-<span class="hljs-number">999</span>)
Basic Salary = Monthly Pay (<span class="hljs-keyword">in</span> rupees)
</code></pre><hr>
<h2 id="entity-relationship-diagram-e-r-diagram-">Entity-Relationship Diagram (E-R Diagram) ğŸ—‚ï¸</h2>
<p>Shows <strong>what data</strong> the system stores and <strong>how it connects</strong>.</p>
<h3 id="main-components-">Main Components:</h3>
<ol>
<li><p><strong>Entity</strong> (ğŸ“¦ Rectangle)</p>
<ul>
<li>What things are stored?</li>
<li>Example: Student, Course, Teacher</li>
</ul>
</li>
<li><p><strong>Relationship</strong> (â—‡ Diamond)</p>
<ul>
<li>How do things connect?</li>
<li>Example: &quot;Student takes Course&quot;</li>
<li>&quot;Teacher teaches Class&quot;[1]</li>
</ul>
</li>
<li><p><strong>Attributes</strong> (âšª Oval)</p>
<ul>
<li>What details do we store?</li>
<li>Example: Student has Name, Roll No, Address[1]</li>
</ul>
</li>
</ol>
<h3 id="relationship-types-">Relationship Types:</h3>
<ul>
<li><strong>One to One</strong>: 1 Teacher = 1 Department Head</li>
<li><strong>One to Many</strong>: 1 Class = Many Students âœ…</li>
<li><strong>Many to Many</strong>: Many Students = Many Courses[1]</li>
</ul>
<hr>
<h2 id="prototyping-building-a-demo-first-">Prototyping - Building a Demo First ğŸ¬</h2>
<p>Instead of building the entire system, build a <strong>small working version</strong> first!</p>
<h3 id="two-types-">Two Types:</h3>
<h4 id="1-throw-away-prototype-">1. <strong>Throw-Away Prototype</strong> ğŸ—‘ï¸</h4>
<ul>
<li>Build quickly</li>
<li>Show to customer</li>
<li>Get feedback</li>
<li>Throw away and build real one</li>
<li><strong>Advantage</strong>: Saves time deciding what to build</li>
<li><strong>Time</strong>: 2-4 weeks typically[1]</li>
</ul>
<h4 id="2-evolutionary-prototype-">2. <strong>Evolutionary Prototype</strong> ğŸŒ±</h4>
<ul>
<li>Build simple version</li>
<li>Add features gradually</li>
<li>Keep improving the same prototype</li>
<li>Final version grows from prototype</li>
<li><strong>Advantage</strong>: Have working system early[1]</li>
</ul>
<h3 id="benefits-of-prototyping-1-">Benefits of Prototyping: âœ…[1]</h3>
<ol>
<li>Find communication gaps early</li>
<li>Discover missing requirements</li>
<li>Show what system will look like</li>
<li>Prove it&#39;s feasible</li>
<li>Base for writing final document</li>
</ol>
<hr>
<h1 id="unit-3-software-design-">Unit 3: Software Design ğŸ¨</h1>
<h2 id="what-is-software-design-">What is Software Design?</h2>
<p>Design = <strong>Creating the blueprint</strong> before building!</p>
<p><strong>Example</strong>: An architect designs a house before builders start. Similarly, designers create system designs before programmers code.[2]</p>
<p><strong>Definition</strong>: Software design = Process of creating a detailed plan that shows how the software will work.[2]</p>
<h2 id="design-process-5-main-things-to-design">Design Process: 5 Main Things to Design</h2>
<h3 id="1-data-design-">1. <strong>Data Design</strong> ğŸ’¾</h3>
<ul>
<li>What data will system store?</li>
<li>How to organize data?</li>
<li>Database structure</li>
<li><strong>Example</strong>: Student database with fields: Name, ID, Address, Marks[2]</li>
</ul>
<h3 id="2-architectural-design-">2. <strong>Architectural Design</strong> ğŸ—ï¸</h3>
<ul>
<li>How are components organized?</li>
<li>Which parts talk to which parts?</li>
<li>Overall structure</li>
<li><strong>Example</strong>: Banking system has: Login Module â†’ Account Module â†’ Transaction Module[2]</li>
</ul>
<h3 id="3-modular-design-">3. <strong>Modular Design</strong> ğŸ§©</h3>
<ul>
<li>Break system into independent modules</li>
<li>Each module does one job well</li>
<li>Modules can work together</li>
<li><strong>Advantage</strong>: Easy to understand and fix[2]</li>
</ul>
<h3 id="4-interface-design-">4. <strong>Interface Design</strong> ğŸ–¥ï¸</h3>
<ul>
<li>How do users interact with system?</li>
<li>Buttons, menus, screens</li>
<li>Where information appears</li>
<li><strong>Goal</strong>: Make it easy and user-friendly[2]</li>
</ul>
<h3 id="5-human-computer-interface-hci-">5. <strong>Human-Computer Interface (HCI)</strong> ğŸ‘¥</h3>
<ul>
<li>How people use the system</li>
<li>Keyboard, mouse, touchscreen</li>
<li>Making it comfortable to use</li>
<li><strong>Focus</strong>: Making humans happy using the system[2]</li>
</ul>
<hr>
<h2 id="design-principles-make-good-designs-">Design Principles: Make Good Designs âœ¨</h2>
<h3 id="1-cohesion-how-well-things-stick-together">1. <strong>Cohesion</strong> ğŸ¯ - How Well Things Stick Together</h3>
<ul>
<li>High cohesion = module does ONE job well âœ…</li>
<li>Low cohesion = module does many unrelated jobs âŒ</li>
</ul>
<p><strong>Example</strong>:</p>
<ul>
<li>âœ… <strong>Good</strong>: Login Module only handles login</li>
<li>âŒ <strong>Bad</strong>: Login Module handles login + payment + reports (too much!)[2]</li>
</ul>
<h3 id="2-coupling-how-much-modules-depend-on-each-other">2. <strong>Coupling</strong> ğŸ”— - How Much Modules Depend on Each Other</h3>
<ul>
<li>Low coupling = Modules are independent âœ…</li>
<li>High coupling = Modules depend heavily on each other âŒ</li>
</ul>
<p><strong>Example</strong>:</p>
<ul>
<li>âœ… <strong>Good</strong>: Login Module doesn&#39;t need to know about Payment Module</li>
<li>âŒ <strong>Bad</strong>: Payment Module needs to access 10 other modules&#39; data[2]</li>
</ul>
<h3 id="goal-high-cohesion-low-coupling-2-">Goal: HIGH COHESION + LOW COUPLING â­[2]</h3>
<hr>
<h2 id="interface-design-making-software-easy-to-use-">Interface Design - Making Software Easy to Use ğŸ’¡</h2>
<h3 id="old-way-command-line-">Old Way - Command Line âŒ</h3>
<pre><code>&gt; <span class="hljs-built_in">run</span> prog1.exe i2 message <span class="hljs-keyword">on</span>
</code></pre><ul>
<li>Confusing! What does &quot;i2 message on&quot; mean?</li>
<li>Users must memorize commands</li>
<li>Lots of errors[2]</li>
</ul>
<h3 id="modern-way-graphical-user-interface-gui-">Modern Way - Graphical User Interface (GUI) âœ…</h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  My Application     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â–¡ File  â–¡ Edit      â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ [<span class="hljs-keyword">Run</span><span class="bash">] [Stop]    â”‚ â”‚
</span>â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><ul>
<li>Easy to understand</li>
<li>Buttons instead of commands</li>
<li>Pictures/icons help[2]</li>
</ul>
<h3 id="10-rules-for-good-interface-design-2-">10 Rules for Good Interface Design: ğŸ“‹[2]</h3>
<ol>
<li><strong>Consistency</strong> - Same things look and work the same everywhere</li>
<li><strong>Shortcuts</strong> - Power users can work faster (Ctrl+S for save)</li>
<li><strong>Feedback</strong> - System tells user what happened</li>
<li><strong>Prevent Errors</strong> - Don&#39;t let users make mistakes</li>
<li><strong>Allow Undo</strong> - Users can take back actions</li>
<li><strong>Memory Help</strong> - Don&#39;t make users remember everything</li>
<li><strong>Relevant Info</strong> - Show only what&#39;s needed now</li>
<li><strong>Screen Size</strong> - Fit important stuff on screen</li>
<li><strong>Less Typing</strong> - Use dropdowns instead of typing</li>
<li><strong>Help Everywhere</strong> - Teach users how to use it[2]</li>
</ol>
<hr>
<h2 id="user-experience-ux-design-">User Experience (UX) Design ğŸ­</h2>
<h3 id="ux-vs-ui-what-s-the-difference-">UX vs UI: What&#39;s the Difference?</h3>
<table>
<thead>
<tr>
<th>UI (User Interface)</th>
<th>UX (User Experience)</th>
</tr>
</thead>
<tbody>
<tr>
<td>The buttons and menus</td>
<td>How user feels using product</td>
</tr>
<tr>
<td>How it looks</td>
<td>How easy/enjoyable it is</td>
</tr>
<tr>
<td>The screen</td>
<td>The entire journey</td>
<td>[2]</td>
</tr>
</tbody>
</table>
<h3 id="example-mobile-phone-">Example - Mobile Phone:</h3>
<ul>
<li><strong>UI</strong>: Icons, buttons, screens look pretty</li>
<li><strong>UX</strong>: Phone feels smooth, fast, intuitive to use</li>
</ul>
<p><strong>Bad UI + Bad UX</strong>: Confusing buttons + slow = User angry âŒ
<strong>Good UI + Bad UX</strong>: Pretty buttons + slow = User angry âŒ
<strong>Good UI + Good UX</strong>: Pretty buttons + fast + easy = User happy âœ…[2]</p>
<hr>
<h2 id="design-for-mobility-">Design for Mobility ğŸ“±</h2>
<p>Today, everything must work on phones and tablets!</p>
<h3 id="key-things-to-remember-">Key Things to Remember:</h3>
<ol>
<li><strong>Smaller screens</strong> - Don&#39;t show too much</li>
<li><strong>Touch, not mouse</strong> - Buttons must be bigger</li>
<li><strong>Different phones</strong> - Work on iPhone, Android, etc.</li>
<li><strong>Different operating systems</strong> - Different rules</li>
<li><strong>Offline mode</strong> - Should work without internet[2]</li>
</ol>
<hr>
<h2 id="design-patterns-">Design Patterns ğŸ¯</h2>
<p>A <strong>design pattern</strong> = Solution to a problem that happens often.</p>
<p><strong>Simple Definition</strong>: &quot;If this is your problem, do this solution.&quot;</p>
<h3 id="example-patterns-2-">Example Patterns:[2]</h3>
<ul>
<li><strong>Navigation Pattern</strong>: How to move between screens</li>
<li><strong>Login Pattern</strong>: Standard way to log in</li>
<li><strong>Search Pattern</strong>: Standard way to find things</li>
<li><strong>Payment Pattern</strong>: Standard way to pay[2]</li>
</ul>
<p><strong>Benefit</strong>: Don&#39;t invent wheel again - use proven solutions!</p>
<hr>
<h2 id="key-takeaways-">Key Takeaways ğŸ“</h2>
<h3 id="unit-2-">Unit 2:</h3>
<ol>
<li><strong>Requirements</strong> = What system should do</li>
<li><strong>SRS</strong> = Detailed document describing everything</li>
<li><strong>DFD</strong> = Shows how data flows</li>
<li><strong>E-R Diagram</strong> = Shows what data is stored</li>
<li><strong>Prototyping</strong> = Build quick demo first</li>
</ol>
<h3 id="unit-3-">Unit 3:</h3>
<ol>
<li><strong>Design</strong> = Blueprint before building</li>
<li><strong>High Cohesion + Low Coupling</strong> = Good design</li>
<li><strong>Interface</strong> = How users interact (make it easy!)</li>
<li><strong>UX</strong> = Overall experience</li>
<li><strong>Design Patterns</strong> = Use proven solutions</li>
</ol>
<hr>
<p>Perfect! Now let me teach you <strong>Unit 4</strong> and <strong>Unit 5</strong> in simple language! ğŸ“</p>
<hr>
<h1 id="unit-4-software-quality-and-security-">Unit 4: Software Quality and Security ğŸ›¡ï¸</h1>
<h2 id="what-is-software-quality-">What is Software Quality?</h2>
<p><strong>Simple Definition</strong>: Quality = Software that does what it&#39;s supposed to do, on time, within budget, and has no bugs (or very few).[1]</p>
<p>Think of buying a phone. A quality phone:</p>
<ul>
<li>Works properly âœ…</li>
<li>Doesn&#39;t crash âŒ</li>
<li>Has all features promised âœ…</li>
<li>Looks nice âœ…</li>
<li>Works for a long time âœ…</li>
</ul>
<hr>
<h2 id="what-makes-quality-software-11-key-attributes-">What Makes Quality Software? 11 Key Attributes ğŸŒŸ</h2>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Auditability</strong></td>
<td>Can test if it follows standards</td>
</tr>
<tr>
<td><strong>Compatibility</strong></td>
<td>Works with other systems</td>
</tr>
<tr>
<td><strong>Completeness</strong></td>
<td>Has all required features</td>
</tr>
<tr>
<td><strong>Consistency</strong></td>
<td>No contradictions, uniform</td>
</tr>
<tr>
<td><strong>Correctness</strong></td>
<td>Free from errors</td>
</tr>
<tr>
<td><strong>Feasibility</strong></td>
<td>Can be built with available resources</td>
</tr>
<tr>
<td><strong>Modularity</strong></td>
<td>Easy to change one part without affecting others</td>
</tr>
<tr>
<td><strong>Testability</strong></td>
<td>Easy to test</td>
</tr>
<tr>
<td><strong>Traceability</strong></td>
<td>Can trace features back to requirements</td>
</tr>
<tr>
<td><strong>Understandability</strong></td>
<td>Code is clear and readable</td>
</tr>
<tr>
<td><strong>Robustness</strong></td>
<td>Works even with wrong inputs</td>
<td>[1]</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="common-causes-of-software-errors-1-">Common Causes of Software Errors âš ï¸[1]</h2>
<ol>
<li><strong>Misunderstanding requirements</strong> - Didn&#39;t understand what customer wants</li>
<li><strong>Bad specifications</strong> - Incomplete or wrong specs</li>
<li><strong>Logic errors</strong> - Wrong code logic</li>
<li><strong>Not following standards</strong> - Didn&#39;t follow coding rules</li>
<li><strong>Incomplete testing</strong> - Didn&#39;t test enough</li>
<li><strong>Bad documentation</strong> - No clear notes</li>
<li><strong>Data modeling errors</strong> - Wrong database design</li>
</ol>
<hr>
<h2 id="how-to-measure-quality-">How to Measure Quality? ğŸ“Š</h2>
<h3 id="three-ways-to-measure-">Three Ways to Measure:</h3>
<h4 id="1-defect-metrics-">1. <strong>Defect Metrics</strong> ğŸ›</h4>
<p>Count how many bugs:</p>
<ul>
<li>Number of errors in code</li>
<li>Number of bugs found during testing</li>
<li><strong>Example</strong>: Found 15 bugs in 10,000 lines of code</li>
</ul>
<h4 id="2-reliability-metrics-">2. <strong>Reliability Metrics</strong> â±ï¸</h4>
<ul>
<li><strong>MTTF</strong> = Mean Time To Failure</li>
<li>How long before system breaks?</li>
<li><strong>Example</strong>: System runs 1000 hours before crashing</li>
</ul>
<h4 id="3-complexity-metrics-">3. <strong>Complexity Metrics</strong> ğŸ“ˆ</h4>
<ul>
<li>How complex is the code?</li>
<li><strong>Cyclomatic Complexity</strong> = Measures number of paths through code</li>
<li>Formula: <strong>V(G) = e - n + 2</strong><ul>
<li>e = edges (connections)</li>
<li>n = nodes (points)</li>
<li>More paths = harder to test[1]</li>
</ul>
</li>
</ul>
<hr>
<h2 id="software-quality-assurance-sqa-process-">Software Quality Assurance (SQA) Process ğŸ”</h2>
<p><strong>SQA</strong> = All activities done to ensure quality throughout development.</p>
<h3 id="key-activities-">Key Activities:</h3>
<ol>
<li><strong>Define Requirements</strong> - What does quality mean?</li>
<li><strong>Review Processes</strong> - Are we doing things right?</li>
<li><strong>Test Products</strong> - Does software work?</li>
<li><strong>Measure Quality</strong> - Can we measure it?</li>
<li><strong>Report &amp; Improve</strong> - Tell what&#39;s wrong and fix it[1]</li>
</ol>
<h3 id="who-does-qa-">Who Does QA?</h3>
<table>
<thead>
<tr>
<th>Role</th>
<th>Responsibility</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Software Engineers</strong></td>
<td>Write good code, test, participate in reviews</td>
</tr>
<tr>
<td><strong>QA Team</strong></td>
<td>Plan quality activities, audit everything</td>
</tr>
<tr>
<td><strong>Managers</strong></td>
<td>Support quality efforts</td>
</tr>
<tr>
<td><strong>Customers</strong></td>
<td>Confirm quality standards</td>
<td>[1]</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="formal-technical-review-ftr-">Formal Technical Review (FTR) ğŸ¯</h2>
<p><strong>FTR</strong> = Official meeting where people review code/documents before release.</p>
<h3 id="what-gets-reviewed-">What Gets Reviewed?</h3>
<ol>
<li><strong>Requirements</strong> - Is SRS complete and clear?</li>
<li><strong>Design</strong> - Is design good?</li>
<li><strong>Code</strong> - Is code following standards?</li>
<li><strong>Testing</strong> - Are tests good?[1]</li>
</ol>
<h3 id="review-process-">Review Process:</h3>
<pre><code><span class="hljs-symbol">Product</span> Ready â†’ Project Manager â†’ <span class="hljs-keyword">Review </span>Leader â†’ <span class="hljs-keyword">Reviewers </span><span class="hljs-keyword">Review
</span>                                                     â†“
                                            <span class="hljs-keyword">Review </span>Meeting (<span class="hljs-number">2</span> hours max)
                                                     â†“
<span class="hljs-symbol">                                    Decide:</span> Accept/Accept with changes/Reject
                                                     â†“
                                            Write <span class="hljs-keyword">Review </span>Report
</code></pre><h3 id="review-results-">Review Results:</h3>
<p>âœ… <strong>Accept</strong> - No changes needed
âœï¸ <strong>Accept with Changes</strong> - Make small fixes
âŒ <strong>Reject</strong> - Major problems, redo it[1]</p>
<hr>
<h2 id="software-reliability-">Software Reliability ğŸ”—</h2>
<p><strong>Reliability</strong> = Probability software will work without failure for a certain time.</p>
<p><strong>Simple Example</strong>:</p>
<ul>
<li>Phone works 99% of the time = 99% reliable</li>
<li>Car breaks every 6 months = 50% reliable</li>
</ul>
<h3 id="key-metrics-">Key Metrics:</h3>
<ul>
<li><strong>MTTF</strong> (Mean Time To Failure) = Average time before failure<ul>
<li><strong>Example</strong>: Software crashes after 500 hours on average[1]</li>
</ul>
</li>
</ul>
<h3 id="formula-for-reliability-">Formula for Reliability:</h3>
<p><strong>D(t) = Ta(1 - e^-bct)</strong></p>
<p>Where:</p>
<ul>
<li>D(t) = Cumulative defects over time</li>
<li>Ta = Total defects possible</li>
<li>b, c = Constants based on history[1]</li>
</ul>
<hr>
<h2 id="software-quality-standards-">Software Quality Standards ğŸ“‹</h2>
<p>Two Main Standards:</p>
<h3 id="1-cmm-capability-maturity-model-5-levels-">1. <strong>CMM (Capability Maturity Model)</strong> - 5 Levels:</h3>
<table>
<thead>
<tr>
<th>Level</th>
<th>Name</th>
<th>What It Means</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>Initial</td>
<td>Chaotic, no real process</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>Repeatable</td>
<td>Basic project management</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>Defined</td>
<td>Standard processes everywhere</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>Managed</td>
<td>Measured with numbers, predictable</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>Optimizing</td>
<td>Always improving</td>
<td>[1]</td>
</tr>
</tbody>
</table>
<h3 id="2-iso-9001-2000-generic-quality-standard">2. <strong>ISO 9001:2000</strong> - Generic Quality Standard</h3>
<ul>
<li>Can be used by ANY organization</li>
<li>Focuses on having documented processes</li>
<li>Helps organization be organized</li>
<li><strong>Note</strong>: ISO certification = follows good process, NOT necessarily good products![1]</li>
</ul>
<hr>
<h2 id="security-engineering-">Security Engineering ğŸ”</h2>
<p><strong>Why Security?</strong></p>
<ul>
<li>Prevent attacks</li>
<li>Protect data</li>
<li>Ensure user privacy</li>
<li>Stop fraud[1]</li>
</ul>
<h3 id="security-activities-">Security Activities:</h3>
<ol>
<li><strong>Analyze threats</strong> - What can go wrong?</li>
<li><strong>Design security</strong> - How to prevent attacks?</li>
<li><strong>Implement security</strong> - Build protection</li>
<li><strong>Test security</strong> - Does it work?</li>
<li><strong>Maintain security</strong> - Keep updating[1]</li>
</ol>
<hr>
<h1 id="unit-5-software-project-planning-">Unit 5: Software Project Planning ğŸ“Š</h1>
<h2 id="why-plan-projects-">Why Plan Projects?</h2>
<p><strong>The Problem</strong>: Most software projects go over budget and over time! ğŸ˜±</p>
<p><strong>The Solution</strong>: Use scientific estimation instead of guessing.[2]</p>
<p><strong>Key Phrase</strong>: &quot;If you cannot measure it, then you cannot improve it!&quot;[2]</p>
<hr>
<h2 id="what-to-estimate-">What to Estimate?</h2>
<p>Project managers must estimate 4 things:</p>
<ol>
<li><strong>SIZE</strong> - How big is the project?</li>
<li><strong>EFFORT</strong> - How many people-months needed?</li>
<li><strong>SCHEDULE</strong> - How many months to complete?</li>
<li><strong>COST</strong> - How much will it cost?[2]</li>
</ol>
<hr>
<h2 id="types-of-metrics-">Types of Metrics ğŸ“</h2>
<h3 id="1-product-metrics-measures-the-software-itself-">1. <strong>Product Metrics</strong> - Measures the software itself:</h3>
<ul>
<li><strong>LOC</strong> (Lines of Code) - How many lines?</li>
<li><strong>Function Points</strong> - How much functionality?</li>
<li>Pages of documentation</li>
<li>Number of test cases[2]</li>
</ul>
<h3 id="2-process-metrics-measures-the-development-process-">2. <strong>Process Metrics</strong> - Measures the development process:</h3>
<ul>
<li>Time taken</li>
<li>Effort (man-months)</li>
<li>Cost</li>
<li>Defects found[2]</li>
</ul>
<h3 id="3-primitive-vs-derived-metrics-">3. <strong>Primitive vs Derived Metrics</strong>:</h3>
<p><strong>Primitive</strong> = What you can directly see:</p>
<ul>
<li>Lines of code = 1000</li>
<li>Hours worked = 500</li>
</ul>
<p><strong>Derived</strong> = Calculated from primitives:</p>
<ul>
<li>Productivity = 1000 LOC / 500 hours = 2 LOC per hour</li>
<li>Quality = 10 bugs / 1000 LOC = 0.01 bugs per line[2]</li>
</ul>
<hr>
<h2 id="size-measurement-loc-vs-function-points">Size Measurement: LOC vs Function Points</h2>
<h3 id="-loc-lines-of-code-"><strong>LOC (Lines of Code)</strong> ğŸ“</h3>
<p><strong>Idea</strong>: Count number of lines in code</p>
<p><strong>Problem</strong>: Same program has different LOC in different languages!</p>
<p><strong>Example</strong>:</p>
<pre><code><span class="hljs-keyword">Module</span> <span class="hljs-keyword">in</span> COBOL: <span class="hljs-number">24</span>,<span class="hljs-number">000</span> lines
Same <span class="hljs-keyword">Module</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">Assembly</span>: <span class="hljs-number">800</span>,<span class="hljs-number">000</span> lines
Same <span class="hljs-keyword">Module</span> <span class="hljs-keyword">in</span> <span class="hljs-number">4</span>GL: <span class="hljs-number">400</span> lines
</code></pre><p>It&#39;s the same module! But LOC varies wildly ğŸ˜…[2]</p>
<hr>
<h3 id="-function-points-better-than-loc-"><strong>Function Points</strong> â­ (Better than LOC!)</h3>
<p><strong>Idea</strong>: Measure what the software DOES, not how many lines of code.</p>
<p><strong>Don&#39;t count lines... Count Features!</strong></p>
<h4 id="5-things-counted-in-function-points-">5 Things Counted in Function Points:</h4>
<ol>
<li><p><strong>External Inputs</strong> ğŸ“¥</p>
<ul>
<li>How many ways to enter data?</li>
<li><strong>Example</strong>: Login, Search, Filter</li>
</ul>
</li>
<li><p><strong>External Outputs</strong> ğŸ“¤</p>
<ul>
<li>How many reports or screens?</li>
<li><strong>Example</strong>: Invoice, Receipt, Dashboard</li>
</ul>
</li>
<li><p><strong>External Inquiries</strong> ğŸ”</p>
<ul>
<li>How many queries?</li>
<li><strong>Example</strong>: &quot;Find student by ID&quot;, &quot;Get balance&quot;</li>
</ul>
</li>
<li><p><strong>Internal Files</strong> ğŸ’¾</p>
<ul>
<li>How many internal databases?</li>
<li><strong>Example</strong>: Student database, Product inventory</li>
</ul>
</li>
<li><p><strong>External Files</strong> ğŸ”—</p>
<ul>
<li>How many external databases?</li>
<li><strong>Example</strong>: Tax database, Bank system[2]</li>
</ul>
</li>
</ol>
<h4 id="complexity-levels-">Complexity Levels:</h4>
<p>Each feature rated as:</p>
<ul>
<li><strong>Low</strong> = Simple</li>
<li><strong>Medium</strong> = Normal</li>
<li><strong>High</strong> = Complex</li>
</ul>
<h4 id="points-assignment-table-">Points Assignment Table:</h4>
<table>
<thead>
<tr>
<th>Feature Type</th>
<th>Low</th>
<th>Medium</th>
<th>High</th>
</tr>
</thead>
<tbody>
<tr>
<td>External Inputs</td>
<td>2</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>External Outputs</td>
<td>4</td>
<td>6</td>
<td>8</td>
</tr>
<tr>
<td>External Inquiries</td>
<td>3</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td>Internal Files</td>
<td>6</td>
<td>8</td>
<td>10</td>
</tr>
<tr>
<td>External Files</td>
<td>5</td>
<td>7</td>
<td>9</td>
<td>[2]</td>
</tr>
</tbody>
</table>
<p><strong>Example Calculation</strong>:</p>
<ul>
<li>5 Low Inputs = 5 Ã— 2 = 10 points</li>
<li>3 Medium Outputs = 3 Ã— 6 = 18 points</li>
<li>2 High Files = 2 Ã— 10 = 20 points</li>
<li><strong>Total = 48 Function Points</strong></li>
</ul>
<h4 id="benefits-">Benefits:</h4>
<p>âœ… Independent of language (same everywhere)
âœ… User-friendly (based on what user sees)
âœ… Can be calculated early in project
âœ… Same FPs even with different technologies[2]</p>
<hr>
<h2 id="project-estimation-steps-">Project Estimation Steps ğŸ¯</h2>
<h3 id="step-1-estimate-size">Step 1: Estimate SIZE</h3>
<p>Where does size come from?</p>
<ul>
<li><strong>Analogy</strong>: &quot;Similar project was 5000 LOC, so this one is too&quot;</li>
<li><strong>Decomposition</strong>: &quot;Break into pieces, estimate each&quot;[2]</li>
</ul>
<h3 id="step-2-estimate-effort">Step 2: Estimate EFFORT</h3>
<p>Once size is known:</p>
<ul>
<li>Use historical data from past projects</li>
<li>Use mathematical models</li>
<li><strong>Effort = f(Size)</strong>[2]</li>
</ul>
<h3 id="step-3-estimate-schedule">Step 3: Estimate SCHEDULE</h3>
<p>Convert effort to calendar time:</p>
<p><strong>Formula</strong>: Schedule (months) = 3.0 Ã— (Effort in man-months)^(1/3)</p>
<p><strong>Example</strong>: </p>
<ul>
<li>12 man-months effort</li>
<li>Schedule = 3.0 Ã— (12)^(1/3) = 3.0 Ã— 2.29 = <strong>6.9 months</strong>[2]</li>
</ul>
<h3 id="step-4-estimate-cost">Step 4: Estimate COST</h3>
<p>Total cost includes:</p>
<ul>
<li>Effort cost (salary)</li>
<li>Hardware cost</li>
<li>Travel expenses</li>
<li>Training cost</li>
<li>Communication cost[2]</li>
</ul>
<hr>
<h2 id="estimation-models-predicting-the-future-">Estimation Models: Predicting the Future ğŸ”®</h2>
<h3 id="1-cocomo-model-most-famous-">1. <strong>COCOMO Model</strong> (Most Famous!)</h3>
<p><strong>COCOMO</strong> = Constructive Cost Model</p>
<p><strong>Formula</strong>: E = a Ã— S^b Ã— m</p>
<p>Where:</p>
<ul>
<li>E = Effort (man-months)</li>
<li>S = Size in LOC</li>
<li>a, b = Constants (different for each project type)</li>
<li>m = Multiplier (adjustment factor)[2]</li>
</ul>
<p><strong>Three Types of Projects</strong>:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Size</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Organic</strong></td>
<td>Small</td>
<td>Simple apps, team knows domain</td>
</tr>
<tr>
<td><strong>Semi-detached</strong></td>
<td>Medium</td>
<td>Normal projects, mixed requirements</td>
</tr>
<tr>
<td><strong>Embedded</strong></td>
<td>Large</td>
<td>Flight control, medical software</td>
<td>[2]</td>
</tr>
</tbody>
</table>
<p><strong>Accuracy</strong>: Barry Boehm says Â± 20% (pretty good!)[2]</p>
<p><strong>Cost Drivers</strong> (Things that make projects harder):</p>
<ul>
<li>Database size</li>
<li>Complexity</li>
<li>Reliability needed</li>
<li>Performance constraints</li>
<li>Team capability</li>
<li>Schedule pressure[2]</li>
</ul>
<hr>
<h3 id="2-putnam-s-model-">2. <strong>Putnam&#39;s Model</strong></h3>
<p>Uses <strong>Rayleigh Curve</strong> (bell shape):</p>
<ul>
<li>Shows when people are most productive</li>
<li>Early = ramp up</li>
<li>Middle = peak productivity</li>
<li>End = wind down[2]</li>
</ul>
<hr>
<h3 id="3-statistical-model-">3. <strong>Statistical Model</strong></h3>
<p>Simple formula based on data:</p>
<p><strong>E = 5.2 Ã— L^0.91</strong></p>
<p>Where:</p>
<ul>
<li>E = Effort (man-months)</li>
<li>L = Lines of code</li>
<li>Easier to remember than COCOMO![2]</li>
</ul>
<hr>
<h2 id="estimation-tools-">Estimation Tools ğŸ› ï¸</h2>
<p>Many software tools automate estimation:</p>
<table>
<thead>
<tr>
<th>Tool</th>
<th>What It Does</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>EstimatorPal</strong></td>
<td>Function points, use cases, task-based</td>
</tr>
<tr>
<td><strong>COCOMO II</strong></td>
<td>Uses COCOMO model</td>
</tr>
<tr>
<td><strong>ESTIMACS</strong></td>
<td>Effort, cost, schedule</td>
</tr>
<tr>
<td><strong>Checkpoint</strong></td>
<td>Guide through estimation</td>
</tr>
<tr>
<td><strong>SEER-SEM</strong></td>
<td>Predicts resources, staffing, risk</td>
<td>[2]</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="common-estimation-mistakes-">Common Estimation Mistakes âŒ</h2>
<h3 id="problems-that-make-estimates-wrong-">Problems That Make Estimates Wrong:</h3>
<ol>
<li><strong>Rushing estimates</strong> - Not enough time to estimate</li>
<li><strong>Using old data</strong> - Past projects different from new</li>
<li><strong>Unclear requirements</strong> - Don&#39;t know what building</li>
<li><strong>Ignoring history</strong> - Not using lessons from past</li>
<li><strong>Forced estimates</strong> - &quot;Do it in 2 months&quot; (impossible!)</li>
<li><strong>Only estimating LOC</strong> - Forget about design, testing</li>
<li><strong>Adding people late</strong> - New people need training[2]</li>
</ol>
<h3 id="how-to-estimate-better-">How to Estimate Better:</h3>
<p>âœ… Save historical data from past projects
âœ… Allow time for estimation
âœ… Involve people who&#39;ll actually do the work
âœ… Use estimation tools
âœ… Re-estimate during project
âœ… Learn from past mistakes[2]</p>
<hr>
<h2 id="cost-vs-time-tradeoff-">Cost vs Time Tradeoff ğŸ“‰</h2>
<p><strong>Basic Truth</strong>: You can reduce cost by taking more time</p>
<ul>
<li><strong>Short project</strong> = High cost (need overtime, extra people)</li>
<li><strong>Long project</strong> = Lower cost (spread out work)</li>
<li><strong>Reality</strong>: Customers want both fast AND cheap! ğŸ˜…[2]</li>
</ul>
<hr>
<h2 id="key-takeaways-">Key Takeaways ğŸ“</h2>
<h3 id="unit-4-">Unit 4:</h3>
<ol>
<li><strong>Quality</strong> = meets requirements, no bugs, on time/budget</li>
<li><strong>Measure quality</strong> with defects, reliability, complexity</li>
<li><strong>FTR</strong> = Official code reviews catch errors early</li>
<li><strong>Reliability</strong> = probability software works without crashing</li>
<li><strong>CMM Levels</strong> = Maturity of organization (1-5)</li>
<li><strong>Security</strong> = Protect data, prevent attacks</li>
</ol>
<h3 id="unit-5-">Unit 5:</h3>
<ol>
<li><strong>Metrics</strong> = Measure everything!</li>
<li><strong>LOC</strong> = Count code lines (bad for comparing languages)</li>
<li><strong>Function Points</strong> = Count features (better!)</li>
<li><strong>COCOMO</strong> = Most popular estimation model</li>
<li><strong>Estimation Steps</strong> = Size â†’ Effort â†’ Schedule â†’ Cost</li>
<li><strong>Estimation Errors</strong> = Common and costly!</li>
</ol>
<hr>
<p>Perfect! Now let me teach you <strong>Unit 6</strong> and <strong>Unit 7</strong> in simple language! ğŸ“</p>
<hr>
<h1 id="unit-6-risk-management-and-project-scheduling-">Unit 6: Risk Management and Project Scheduling ğŸ¯</h1>
<h2 id="what-is-risk-">What is Risk?</h2>
<p><strong>Risk</strong> = A potential problem that <strong>might happen</strong> (but may not!).[1]</p>
<p><strong>Simple Example</strong>:</p>
<ul>
<li>You plan to go outside â†’ Risk: It might rain ğŸŒ§ï¸</li>
<li>In software: You code a feature â†’ Risk: It might not work with other modules</li>
</ul>
<p><strong>Key Point</strong>: Always assume risk <strong>might occur</strong> and plan for it![1]</p>
<hr>
<h2 id="types-of-software-risks-">Types of Software Risks âš ï¸</h2>
<table>
<thead>
<tr>
<th>Risk Type</th>
<th>Problem</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Skills/Knowledge</strong></td>
<td>Team doesn&#39;t know technology</td>
<td>New language, framework</td>
</tr>
<tr>
<td><strong>Interface Modules</strong></td>
<td>Modules don&#39;t connect properly</td>
<td>Data type mismatch</td>
</tr>
<tr>
<td><strong>Tool Knowledge</strong></td>
<td>Team doesn&#39;t know development tools</td>
<td>IDE, debugging tools</td>
</tr>
<tr>
<td><strong>Programming Skills</strong></td>
<td>Code is inefficient or buggy</td>
<td>Poor performance, crashes</td>
</tr>
<tr>
<td><strong>Management Issues</strong></td>
<td>Bad team communication</td>
<td>No training, poor coordination</td>
</tr>
<tr>
<td><strong>Hardware Updates</strong></td>
<td>New hardware/OS released</td>
<td>Phone update breaks app</td>
</tr>
<tr>
<td><strong>Customer Risks</strong></td>
<td>Customer unsure of requirements</td>
<td>Unclear specifications</td>
</tr>
<tr>
<td><strong>External Risks</strong></td>
<td>Data loss, security breach</td>
<td>Server hack, fire</td>
</tr>
<tr>
<td><strong>Commercial Risks</strong></td>
<td>Competitors beat you to market</td>
<td>Delayed delivery</td>
<td>[1]</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="risk-management-process-">Risk Management Process ğŸ”„</h2>
<p>4 Steps to manage risk:</p>
<h3 id="step-1-risk-avoidance-prevent-it-">Step 1: <strong>Risk Avoidance</strong> - Prevent It! ğŸ›¡ï¸</h3>
<ul>
<li><strong>Risk Anticipation</strong>: Know common problems from past projects</li>
<li><strong>Risk Tools</strong>: Use tools to test for known risks[1]</li>
</ul>
<h3 id="step-2-risk-detection-find-it-">Step 2: <strong>Risk Detection</strong> - Find It! ğŸ”</h3>
<p><strong>Risk Analysis</strong>:</p>
<ul>
<li>Calculate: <strong>Risk Exposure = Probability Ã— Weight Factor</strong></li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code>Risk: Stack Overflow
Probability of <span class="hljs-attr">occurrence</span> = <span class="hljs-number">5</span>
Weight <span class="hljs-attr">factor</span> = <span class="hljs-number">15</span>
Risk <span class="hljs-attr">Exposure</span> = <span class="hljs-number">5</span> Ã— <span class="hljs-number">15</span> = <span class="hljs-number">75</span> (Medium priority)

Risk: No Password Forgot option
<span class="hljs-attr">Probability</span> = <span class="hljs-number">7</span>
<span class="hljs-attr">Weight</span> = <span class="hljs-number">20</span>
Risk <span class="hljs-attr">Exposure</span> = <span class="hljs-number">7</span> Ã— <span class="hljs-number">20</span> = <span class="hljs-number">140</span> (HIGH priority - fix first!)
</code></pre><p><strong>Risk Prioritization</strong>: Highest exposure = Fix first![1]</p>
<h3 id="step-3-risk-control-stop-it-">Step 3: <strong>Risk Control</strong> - Stop It! â›”</h3>
<p>Options:</p>
<ul>
<li><strong>Risk Pending</strong>: Low priority risks â†’ Handle later</li>
<li><strong>Risk Resolution</strong>: Find solutions (eliminate, transfer, or disclose)</li>
<li><strong>Risk Transfer</strong>: Move risk to another module</li>
<li><strong>Disclosure</strong>: Tell customer about risk</li>
<li><strong>Risk Not Solvable</strong>: Propose alternate feature[1]</li>
</ul>
<h3 id="step-4-risk-recovery-fix-it-">Step 4: <strong>Risk Recovery</strong> - Fix It! ğŸ”§</h3>
<p>Options:</p>
<ul>
<li><strong>Full Recovery</strong>: Problem completely solved</li>
<li><strong>Partial Recovery</strong>: Partially solved, monitor</li>
<li><strong>Extra/Alternate Features</strong>: Add features to work around problem[1]</li>
</ul>
<hr>
<h2 id="risk-monitoring-table-">Risk Monitoring Table ğŸ“Š</h2>
<p>Track risks over time:</p>
<table>
<thead>
<tr>
<th>Sl.No</th>
<th>Risk Name</th>
<th>Week 1</th>
<th>Week 2</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Module compute()</td>
<td>Lines 5,8,20</td>
<td>Lines 5,25</td>
<td>Priority 3</td>
</tr>
<tr>
<td>2</td>
<td>Memory needed</td>
<td>f1(),f5()</td>
<td>f2()</td>
<td>Priority 1</td>
<td>[1]</td>
</tr>
</tbody>
</table>
<p>Notice: Risks reduce over time! ğŸ“‰</p>
<hr>
<h2 id="project-scheduling-">Project Scheduling ğŸ“…</h2>
<p><strong>Scheduling</strong> = Breaking project into tasks and timeline</p>
<h3 id="factors-affecting-scheduling-1-">Factors Affecting Scheduling:[1]</h3>
<ol>
<li><strong>Technical Expertise</strong> - Do team members have skills?</li>
<li><strong>Customer Satisfaction</strong> - Regular updates to customer</li>
<li><strong>Technology Updates</strong> - Use latest tools and modules</li>
<li><strong>Full/Partial Implementation</strong> - Deliver in phases</li>
<li><strong>Time Allocation</strong> - How long each phase takes</li>
<li><strong>Module Binding</strong> - Which person does what</li>
<li><strong>Milestones</strong> - Clear deliverables at each phase</li>
<li><strong>Validation &amp; Verification</strong> - Quality checks</li>
</ol>
<hr>
<h2 id="scheduling-techniques-">Scheduling Techniques ğŸ—“ï¸</h2>
<h3 id="1-work-breakdown-structure-wbs-">1. <strong>Work Breakdown Structure (WBS)</strong> ğŸŒ³</h3>
<p>Break project into tree:</p>
<pre><code><span class="hljs-symbol">Software</span> Project
    â”œâ”€â”€ Requirement &amp; Analysis (<span class="hljs-built_in">R1</span>, <span class="hljs-built_in">R2</span>, ... Rn)
    â”œâ”€â”€ Design (<span class="hljs-built_in">D1</span>, <span class="hljs-built_in">D2</span>, ... <span class="hljs-meta">Dn</span>)
    â”œâ”€â”€ Coding (<span class="hljs-built_in">C1</span>, <span class="hljs-built_in">C2</span>, ... <span class="hljs-meta">Cn</span>)
    â”œâ”€â”€ Testing (T1, T2, ... Tn)
    â””â”€â”€ Maintenance (M1, M2, ... Mn)
</code></pre><p><strong>Disadvantage</strong>: No parallel work shown[1]</p>
<hr>
<h3 id="2-flow-graph-">2. <strong>Flow Graph</strong> ğŸ“Š</h3>
<p>Shows which modules depend on which:</p>
<pre><code><span class="hljs-keyword">Start</span> â†’ M1 â†’ M2 â†’ M4 â†’ <span class="hljs-keyword">End</span>
        â†“
        M3 â†—
</code></pre><p>M1 starts, then M2 and M3 run (can be parallel), then M4[1]</p>
<hr>
<h3 id="3-gantt-chart-most-popular-">3. <strong>Gantt Chart</strong> ğŸ“ˆ (Most Popular!)</h3>
<p>Timeline showing tasks and duration:</p>
<pre><code>Task      Week1  Week2  Week3  Week4
<span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">(a1)</span></span>     â–“â–“â–“
<span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">(a2)</span></span>           â–“â–“â–“     
          [Milestone]
<span class="hljs-function"><span class="hljs-title">B</span><span class="hljs-params">(b1)</span></span>                  â–“â–“â–“
<span class="hljs-function"><span class="hljs-title">B</span><span class="hljs-params">(b2)</span></span>                         â–“â–“â–“
          [Milestone]
<span class="hljs-function"><span class="hljs-title">C</span><span class="hljs-params">(c1)</span></span>                  â–“â–“â–“â–“
          [Milestone]
<span class="hljs-function"><span class="hljs-title">D</span><span class="hljs-params">(d1)</span></span>                         â–“â–“â–“
<span class="hljs-function"><span class="hljs-title">D</span><span class="hljs-params">(d2)</span></span>                              â–“â–“
          [Milestone]
</code></pre><p><strong>Advantages</strong>:
âœ… Easy to understand
âœ… Shows milestones
âœ… Shows which tasks are parallel
âœ… Shows duration clearly[1]</p>
<hr>
<h3 id="4-program-evaluation-review-technique-pert-">4. <strong>Program Evaluation Review Technique (PERT)</strong> ğŸ¯</h3>
<p>For high-risk projects, estimate 4 times:</p>
<ol>
<li><strong>t_normal</strong> = Normal conditions</li>
<li><strong>t_min</strong> = With all resources (fastest)</li>
<li><strong>t_max</strong> = With constraints (slowest)</li>
<li><strong>t_history</strong> = From similar past projects</li>
</ol>
<p><strong>Then average them</strong> (sometimes with weights)</p>
<p><strong>Useful for</strong>: Uncertain/risky projects[1]</p>
<hr>
<h2 id="software-project-plan-">Software Project Plan ğŸ“‹</h2>
<p>Complete plan includes:</p>
<p>âœ… Project objectives
âœ… Requirements &amp; specifications
âœ… Milestones &amp; deliverables
âœ… Budget allocation
âœ… Cost, time, size estimates
âœ… Resource allocation (hardware, software, people)
âœ… Risk management strategy
âœ… Scheduling techniques
âœ… Team management
âœ… Quality control standards[1]</p>
<hr>
<h1 id="unit-7-software-testing-">Unit 7: Software Testing ğŸ§ª</h1>
<h2 id="what-is-testing-">What is Testing?</h2>
<p><strong>Testing</strong> = Running program with specific inputs to see if it works correctly[2]</p>
<p><strong>Key Concept</strong>: Testing shows <strong>presence of errors</strong>, NOT absence![2]</p>
<hr>
<h2 id="testing-vs-verification-vs-validation-">Testing vs Verification vs Validation ğŸ”</h2>
<table>
<thead>
<tr>
<th>Term</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Testing</strong></td>
<td>Run program, find errors</td>
</tr>
<tr>
<td><strong>Verification</strong></td>
<td>&quot;Are we building correctly?&quot; (Process check)</td>
</tr>
<tr>
<td><strong>Validation</strong></td>
<td>&quot;Are we building right thing?&quot; (Requirement check)</td>
</tr>
<tr>
<td><strong>Debugging</strong></td>
<td>Find &amp; fix the bugs</td>
<td>[2]</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="basic-testing-terms-">Basic Testing Terms ğŸ“</h2>
<table>
<thead>
<tr>
<th>Term</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Failure</strong></td>
<td>Program doesn&#39;t work as expected</td>
</tr>
<tr>
<td><strong>Fault</strong></td>
<td>Bug in the code (cause of failure)</td>
</tr>
<tr>
<td><strong>Error</strong></td>
<td>Difference between actual and expected result</td>
</tr>
<tr>
<td><strong>Test Case</strong></td>
<td>Input + Expected Output + Test Environment</td>
<td>[2]</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="5-important-testing-laws-2-">5 Important Testing Laws ğŸ“œ[2]</h2>
<ol>
<li><strong>Testing can show errors, NOT their absence</strong> âœ‹</li>
<li><strong>Mix different testing methods</strong> - One method alone isn&#39;t enough</li>
<li><strong>Don&#39;t test your own code</strong> - Bias, miss bugs</li>
<li><strong>80% of errors found in 20% of code</strong> - Focus testing there</li>
<li><strong>Partition testing beats random testing</strong> - Test boundaries, not random</li>
</ol>
<hr>
<h2 id="two-main-testing-strategies-">Two Main Testing Strategies ğŸ¯</h2>
<h3 id="1-black-box-testing-test-what-not-how-">1. <strong>BLACK BOX TESTING</strong> ğŸ”’ (Test What, Not How)</h3>
<ul>
<li>Look only at <strong>input and output</strong></li>
<li>Don&#39;t care about internal code</li>
<li>Based on <strong>requirements/specification</strong></li>
<li>Can test BEFORE code written! â­</li>
</ul>
<p><strong>Advantages</strong>:
âœ… Start early (before coding)
âœ… Test what user sees
âœ… Find deviations from spec</p>
<p><strong>Disadvantages</strong>:
âŒ Can&#39;t detect extra unauthorized code
âŒ Can&#39;t catch additional functions[2]</p>
<hr>
<h3 id="2-white-box-testing-test-how-not-just-what-">2. <strong>WHITE BOX TESTING</strong> ğŸ”“ (Test How, Not Just What)</h3>
<ul>
<li>Look at <strong>internal code structure</strong></li>
<li>Know how program works</li>
<li>Test all code paths and logic</li>
<li>Must wait until code is written ğŸ˜</li>
</ul>
<p><strong>Advantages</strong>:
âœ… Test all internal paths
âœ… Catch extra unauthorized code
âœ… Thorough testing</p>
<p><strong>Disadvantages</strong>:
âŒ Must wait for code
âŒ Time-consuming
âŒ Requires code knowledge[2]</p>
<hr>
<h2 id="black-box-testing-methods-">Black Box Testing Methods ğŸ“¦</h2>
<h3 id="-1-boundary-value-analysis-"><strong>1. Boundary Value Analysis</strong> ğŸ¯</h3>
<p><strong>Idea</strong>: Test <strong>edges/boundaries</strong> of input ranges!</p>
<p><strong>Why?</strong> Errors often happen at boundaries.</p>
<p><strong>Example - Triangle Program</strong>:</p>
<pre><code><span class="hljs-attribute">Input</span>: Three sides (A, B, C)
<span class="hljs-attribute">Range</span>: 0 &lt; sides â‰¤ 100

<span class="nix">Test cases:
âœ“ Valid: <span class="hljs-attr">A=50,</span> <span class="hljs-attr">B=50,</span> <span class="hljs-attr">C=50</span> (middle)
âœ“ Valid: <span class="hljs-attr">A=1,</span> <span class="hljs-attr">B=1,</span> <span class="hljs-attr">C=1</span> (minimum)
âœ“ Valid: <span class="hljs-attr">A=100,</span> <span class="hljs-attr">B=100,</span> <span class="hljs-attr">C=100</span> (maximum)
âœ“ Invalid: <span class="hljs-attr">A=0,</span> <span class="hljs-attr">B=50,</span> <span class="hljs-attr">C=50</span> (just below)
âœ“ Invalid: <span class="hljs-attr">A=101,</span> <span class="hljs-attr">B=50,</span> <span class="hljs-attr">C=50</span> (just above)</span>
</code></pre><hr>
<h3 id="-2-equivalence-partitioning-"><strong>2. Equivalence Partitioning</strong> ğŸ“¦</h3>
<p><strong>Idea</strong>: Divide inputs into <strong>groups</strong> (equivalence classes).</p>
<p>Inputs in same group = treated same way</p>
<p><strong>Example</strong>:</p>
<pre><code><span class="hljs-attribute">Range</span>: 1 to 99

<span class="haml">Classes:
âœ“ Valid: 1 â‰¤ X â‰¤ 99
âœ— Invalid: X &lt; 1
âœ— Invalid: X &gt; 99

Pick ONE test from each class!
-<span class="ruby"> <span class="hljs-symbol">Valid:</span> X = <span class="hljs-number">50</span>
</span>-<span class="ruby"> <span class="hljs-symbol">Invalid:</span> X = <span class="hljs-number">0</span>
</span>-<span class="ruby"> <span class="hljs-symbol">Invalid:</span> X = <span class="hljs-number">100</span></span></span>
</code></pre><hr>
<h2 id="white-box-testing-methods-">White Box Testing Methods ğŸ”</h2>
<h3 id="-1-statement-coverage-"><strong>1. Statement Coverage</strong> ğŸ“„</h3>
<p><strong>Goal</strong>: Execute every line of code at least once!</p>
<pre><code class="lang-python">if (x &gt; 5):        â† Test with x=10 to<span class="hljs-built_in"> execute </span>this line
    print(<span class="hljs-string">"high"</span>)
else:
    print(<span class="hljs-string">"low"</span>)   â† Test with x=2 to<span class="hljs-built_in"> execute </span>this line
</code></pre>
<hr>
<h3 id="-2-branch-coverage-"><strong>2. Branch Coverage</strong> ğŸŒ³</h3>
<p><strong>Goal</strong>: Execute every IF/ELSE path!</p>
<p><strong>Every branch must be true AND false at least once</strong></p>
<pre><code><span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">5</span>) <span class="hljs-literal">and</span> (<span class="hljs-attr">y</span> == <span class="hljs-number">0</span>):
    â† True path: <span class="hljs-attr">x=10,</span> <span class="hljs-attr">y=0</span>
    â† False path: <span class="hljs-attr">x=2,</span> <span class="hljs-attr">y=0</span>
</code></pre><hr>
<h3 id="-3-cyclomatic-complexity-"><strong>3. Cyclomatic Complexity</strong> ğŸ“Š</h3>
<p><strong>Measures</strong>: How many independent paths through code?</p>
<p><strong>Formula</strong>: V(G) = E - N + 2</p>
<ul>
<li>E = number of edges</li>
<li>N = number of nodes</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code>V(G) = 6 - 5 + 2 = 3
<span class="hljs-section">= 3 independent paths to test</span>
</code></pre><p>Higher complexity = harder to test[2]</p>
<hr>
<h3 id="-4-mutation-testing-"><strong>4. Mutation Testing</strong> ğŸ§¬</h3>
<p><strong>Idea</strong>: Intentionally break code and see if tests catch it!</p>
<pre><code>Original code:  <span class="hljs-keyword">if</span> (x &gt; 5)
Mutant code:    <span class="hljs-keyword">if</span> (x &gt;= 5)  â† Changed!

Does test <span class="hljs-keyword">catch</span> <span class="hljs-keyword">this</span> change? YES = Good test
</code></pre><p><strong>Score</strong> = (Killed Mutants / Total Mutants) Ã— 100%[2]</p>
<hr>
<h2 id="testing-levels-">Testing Levels ğŸ—ï¸</h2>
<h3 id="-level-1-unit-testing-"><strong>Level 1: Unit Testing</strong> ğŸ§©</h3>
<ul>
<li>Test <strong>one module</strong> at a time</li>
<li>Done by <strong>developers</strong></li>
<li>Only tests that module, not connections</li>
<li><strong>Tool</strong>: JUnit, TestNG</li>
</ul>
<pre><code><span class="hljs-keyword">Module</span> A tested separately
<span class="hljs-keyword">Module</span> B tested separately
</code></pre><hr>
<h3 id="-level-2-integration-testing-"><strong>Level 2: Integration Testing</strong> ğŸ”—</h3>
<ul>
<li>Test <strong>multiple modules together</strong></li>
<li>Check if modules <strong>connect properly</strong></li>
<li>After unit testing</li>
<li><strong>Goal</strong>: Verify interfaces work</li>
</ul>
<pre><code><span class="hljs-keyword">Module</span> A â†â†’ <span class="hljs-keyword">Module</span> B âœ…
<span class="hljs-keyword">Module</span> B â†â†’ <span class="hljs-keyword">Module</span> <span class="hljs-keyword">C</span> âœ…
</code></pre><hr>
<h3 id="-level-3-system-testing-"><strong>Level 3: System Testing</strong> ğŸŒ</h3>
<ul>
<li>Test <strong>entire system</strong> together</li>
<li>Against <strong>all requirements</strong></li>
<li>Real-world scenarios</li>
<li><strong>Goal</strong>: Complete system works</li>
</ul>
<pre><code>Whole Application â†’ Test <span class="hljs-keyword">all</span> features, performance, security
</code></pre><hr>
<h3 id="-level-4-acceptance-testing-"><strong>Level 4: Acceptance Testing</strong> âœ…</h3>
<ul>
<li>Test by <strong>customer</strong></li>
<li>Custom software only</li>
<li>Verify meets all requirements</li>
<li><strong>Long process</strong>: weeks to months[2]</li>
</ul>
<hr>
<h2 id="debugging-">Debugging ğŸ›</h2>
<p><strong>Debugging</strong> = Find and fix bugs</p>
<p><strong>NOT the same as testing!</strong></p>
<h3 id="debugging-process-2-">Debugging Process:[2]</h3>
<ol>
<li><strong>Identify</strong> - What&#39;s wrong? (from test failure)</li>
<li><strong>Analyze</strong> - Where&#39;s the bug? What&#39;s causing it?</li>
<li><strong>Resolve</strong> - Fix the code</li>
</ol>
<h3 id="debugging-characteristics-2-">Debugging Characteristics:[2]</h3>
<ul>
<li>Symptom &amp; cause can be far apart</li>
<li>Bug may disappear when you fix another bug</li>
<li>Hard to reproduce (real-time systems)</li>
<li>Intermittent bugs (happen sometimes)</li>
</ul>
<h3 id="debugging-approaches-2-">Debugging Approaches:[2]</h3>
<ol>
<li><strong>Brute Force</strong> ğŸ’ª - Add lots of debug prints (least efficient)</li>
<li><strong>Backtracking</strong> â¬…ï¸ - Start at error, trace backwards</li>
<li><strong>Cause Elimination</strong> â“ - List possible causes, test each</li>
</ol>
<hr>
<h2 id="testing-tools-">Testing Tools ğŸ› ï¸</h2>
<p>Examples:</p>
<table>
<thead>
<tr>
<th>Tool</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>JUnit</strong></td>
<td>Unit testing Java</td>
</tr>
<tr>
<td><strong>TestNG</strong></td>
<td>Unit testing</td>
</tr>
<tr>
<td><strong>Selenium</strong></td>
<td>Web app testing</td>
</tr>
<tr>
<td><strong>Sahi</strong></td>
<td>Automated web testing</td>
</tr>
<tr>
<td><strong>AQtest</strong></td>
<td>Functional testing</td>
<td>[2]</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="key-testing-takeaways-">Key Testing Takeaways ğŸ“</h2>
<p>âœ… Test early and often
âœ… Mix black box and white box
âœ… Don&#39;t let developers test own code
âœ… Test boundaries and edges
âœ… Use tools to automate
âœ… Test at all levels (unit â†’ system)
âœ… Debugging is after testing</p>
<hr>
<h1 id="summary-units-6-7-">Summary: Units 6 &amp; 7 ğŸ“</h1>
<h2 id="unit-6-risk-management-scheduling">Unit 6: Risk Management &amp; Scheduling</h2>
<ol>
<li><strong>Risk</strong> = Potential problem</li>
<li><strong>4 Steps</strong>: Avoidance â†’ Detection â†’ Control â†’ Recovery</li>
<li><strong>Scheduling</strong>: Break into tasks and timeline</li>
<li><strong>Tools</strong>: Gantt chart (most popular), WBS, PERT</li>
</ol>
<h2 id="unit-7-testing">Unit 7: Testing</h2>
<ol>
<li><strong>Black Box</strong>: Test input/output, user perspective</li>
<li><strong>White Box</strong>: Test internal code paths</li>
<li><strong>Levels</strong>: Unit â†’ Integration â†’ System â†’ Acceptance</li>
<li><strong>Debugging</strong>: Find and fix bugs after testing</li>
<li><strong>Tools</strong>: JUnit, TestNG, Selenium, etc.</li>
</ol>
<hr>
<h1 id="comprehensive-summary-units-8-9-and-10">COMPREHENSIVE SUMMARY: UNITS 8, 9, AND 10</h1>
<hr>
<h1 id="-unit-8-software-change-management-1-"><strong>UNIT 8: SOFTWARE CHANGE MANAGEMENT</strong>[1]</h1>
<h2 id="-8-2-baselines-1-"><strong>8.2 BASELINES</strong>[1]</h2>
<p><strong>Software Configuration Item (SCI)</strong>[1]</p>
<ul>
<li>Any part of development/deliverable system (software, hardware, firmware, documents)</li>
<li>Examples: System specification, Source code, Design documents, Test plans, Database schema, Project plans</li>
<li>Independently tested, stored, reviewed, and changed</li>
</ul>
<p><strong>Definition of Baseline</strong>[1]</p>
<ul>
<li><strong>Approved software configuration item</strong> that has been reviewed and finalized</li>
<li>Serves as <strong>reference point</strong> for all changes</li>
<li>Must be formally reviewed and agreed upon</li>
<li>Can only be changed through formal change control procedures</li>
<li>Functionally complete with defined quality and features documented</li>
<li>Can be recreated at any point in time</li>
<li>Evolution: Baseline 1 â†’ Approved changes â†’ Baseline 2 â†’ Approved changes â†’ Baseline 3</li>
</ul>
<p><strong>Key Characteristics</strong>[1]
âœ“ Functionally complete with defined functionality
âœ“ Undergoes formal testing and reviews
âœ“ All features documented for reference
âœ“ Provides reference for future changes
âœ“ Creates audit trail of changes</p>
<hr>
<h2 id="-8-3-version-control-1-"><strong>8.3 VERSION CONTROL</strong>[1]</h2>
<p><strong>Definition</strong>: Management of multiple revisions of same item during software development[1]</p>
<p><strong>Version Numbering Structure</strong>[1]</p>
<ul>
<li>Project identifier + Configuration item + Version/Change number</li>
<li>Example: SRS Ver 1.0 â†’ Ver 1.1 â†’ Ver 1.2 (bug fixes, minor features)</li>
<li>Then: Ver 2.0 (major change) while maintaining parallel Ver 1.3 (without major change)</li>
<li>Version numbers allow unique identification throughout lifecycle</li>
</ul>
<p><strong>Check-Out and Check-In Process</strong>[1]</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Meaning</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Check-Out</strong></td>
<td>Copy file from project database to developer&#39;s private area</td>
<td>Allows modification without affecting original</td>
</tr>
<tr>
<td><strong>Check-In</strong></td>
<td>Submit changed file back to database with new version number</td>
<td>Records changes and creates new baseline</td>
</tr>
<tr>
<td><strong>Lock</strong></td>
<td>Baseline locked during modification</td>
<td>Prevents other developers from modifying simultaneously</td>
</tr>
</tbody>
</table>
<p><strong>Example: HTML File Modification</strong>[1]</p>
<ul>
<li><strong>Ver 1.0</strong>: <code>&lt;h1&gt;Welcome to HTML Concepts&lt;/h1&gt;</code></li>
<li><strong>Ver 1.1</strong>: Added email link <code>&lt;a href=&quot;mailto:webmaster@xyz.com&quot;&gt;webmaster&lt;/a&gt;</code></li>
<li><strong>Ver 1.2</strong>: Added graphics</li>
<li><strong>Ver 1.1.1</strong>: Created for text-based browser (parallel version)</li>
</ul>
<p><strong>Version Control Tools</strong>[1]</p>
<ul>
<li>Rational ClearCase</li>
<li>Microsoft Visual SourceSafe</li>
<li>Perform: Source code control, Revision control, Concurrent version control</li>
</ul>
<hr>
<h2 id="-8-4-change-control-1-"><strong>8.4 CHANGE CONTROL</strong>[1]</h2>
<p><strong>Purpose</strong>: Accept and accommodate justifiable changes without affecting product integrity[1]</p>
<p><strong>Change Control Process Flow</strong>[1]</p>
<pre><code>1. <span class="hljs-keyword">Change</span> Request â†’ <span class="hljs-number">2.</span> Evaluation â†’ <span class="hljs-number">3.</span> <span class="hljs-keyword">Change</span> Report
        â†“                    â†“               â†“
   Identify what      Assess merits,     <span class="hljs-keyword">Analyze</span> impact
   needs <span class="hljs-keyword">to</span> <span class="hljs-keyword">change</span>    demerits, side      <span class="hljs-keyword">on</span> <span class="hljs-keyword">system</span>
                      effects

<span class="hljs-number">4.</span> <span class="hljs-keyword">Change</span> Control Authority Decision â†’ <span class="hljs-number">5.</span> Engineering <span class="hljs-keyword">Change</span> <span class="hljs-keyword">Order</span> (<span class="hljs-keyword">if</span> approved)
        YES/<span class="hljs-keyword">NO</span>                              <span class="hljs-keyword">Starting</span> point <span class="hljs-keyword">for</span> implementation

<span class="hljs-number">6.</span> Copy Baseline â†’ <span class="hljs-number">7.</span> Incorporate Changes â†’ <span class="hljs-number">8.</span> <span class="hljs-keyword">Audit</span> &amp; Review
   <span class="hljs-keyword">from</span> <span class="hljs-keyword">database</span>      <span class="hljs-keyword">in</span> <span class="hljs-keyword">private</span> area        <span class="hljs-keyword">by</span> designated team

<span class="hljs-number">9.</span> Testing &amp; QA â†’ <span class="hljs-number">10.</span> Approval â†’ <span class="hljs-number">11.</span> <span class="hljs-keyword">New</span> <span class="hljs-keyword">Version</span> Created <span class="hljs-keyword">for</span> Distribution
</code></pre><p><strong>Change Request Format</strong>[1]</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1.0 Identification</strong></td>
<td>SCI name, version numbers, brief description</td>
</tr>
<tr>
<td><strong>1.1 Requester</strong></td>
<td>Name and contact details</td>
</tr>
<tr>
<td><strong>1.3 Date/Time</strong></td>
<td>When change requested</td>
</tr>
<tr>
<td><strong>2.0 Description</strong></td>
<td>Detailed description, background, examples</td>
</tr>
<tr>
<td><strong>2.2 Justification</strong></td>
<td>Why change is needed</td>
</tr>
<tr>
<td><strong>2.3 Priority</strong></td>
<td>Critical, High, Medium, Low</td>
</tr>
</tbody>
</table>
<p><strong>Change Report Format</strong>[1]</p>
<ul>
<li>Items affected</li>
<li>Change categorization &amp; scope</li>
<li>Technical work &amp; tools required</li>
<li>Technical risks</li>
<li>Cost &amp; time assessment</li>
<li>Evaluator recommendation</li>
<li>Business impact priority</li>
</ul>
<p><strong>Engineering Change Order Format</strong>[1]</p>
<ul>
<li>Configuration items affected</li>
<li>Scope of changes</li>
<li>Technical work &amp; tools needed</li>
<li>Risks</li>
<li>Testing requirements</li>
<li>Review plan</li>
<li>Test plan</li>
</ul>
<p><strong>Benefits of Change Control</strong>[1]
âœ“ Identifies developer responsibility
âœ“ Tracks changes affecting main product
âœ“ Provides development roadmap
âœ“ Supports simultaneous work on multiple versions
âœ“ Professional approach to management
âœ“ Builds customer confidence</p>
<hr>
<h2 id="-8-5-auditing-and-reporting-1-"><strong>8.5 AUDITING AND REPORTING</strong>[1]</h2>
<p><strong>Auditing</strong></p>
<ul>
<li>Ensures changes properly implemented</li>
<li>Checks for undesired side effects</li>
<li>Combination of: Formal Technical Review (technical correctness) + Software Configuration Audit (procedure compliance)</li>
</ul>
<p><strong>Audit Checklist</strong>[1]
âœ“ Formal Technical Review completed?
âœ“ Changes from Change Order incorporated?
âœ“ Changes properly documented?
âœ“ Standards followed?
âœ“ Identification and recording procedures followed?
âœ“ Should be conducted by separate team (not the implementing team)</p>
<p><strong>Reporting (Status Accounting)</strong>[1]</p>
<ul>
<li>Records all changes leading to new version</li>
<li>Bookkeeping of each release</li>
<li>Tracks change history</li>
</ul>
<p><strong>Report Contents</strong>[1]</p>
<ul>
<li>Changes incorporated</li>
<li>Person responsible</li>
<li>Date &amp; time of changes</li>
<li>Effect of change</li>
<li>Reason for change (if bug fix)</li>
<li>Unique number for each change</li>
</ul>
<p><strong>Example Code Reporting</strong>[1]</p>
<pre><code><span class="hljs-comment"># Title: Subroutine Insert Employee Data</span>
<span class="hljs-comment"># Version: Ver 1.1.3</span>
<span class="hljs-comment"># Purpose: Insert employee data in master file</span>
<span class="hljs-comment"># Author: John Wright</span>
<span class="hljs-comment"># Modification History:</span>
<span class="hljs-number">12</span>/<span class="hljs-number">12</span>/<span class="hljs-number">2002</span>: <span class="hljs-keyword">by</span> DKN - Fix bugs <span class="hljs-keyword">from</span> <span class="hljs-keyword">first</span> release
<span class="hljs-number">4</span>/<span class="hljs-number">5</span>/<span class="hljs-number">2003</span>: <span class="hljs-keyword">by</span> SKG - Validate <span class="hljs-built_in">date</span> <span class="hljs-keyword">of</span> birth data
<span class="hljs-number">6</span>/<span class="hljs-number">6</span>/<span class="hljs-number">2004</span>: <span class="hljs-keyword">by</span> SSP - Add <span class="hljs-keyword">error</span> checking module
</code></pre><hr>
<hr>
<h1 id="-unit-9-web-software-engineering-2-"><strong>UNIT 9: WEB SOFTWARE ENGINEERING</strong>[2]</h1>
<h2 id="-9-2-1-characteristics-of-web-applications-2-"><strong>9.2.1 CHARACTERISTICS OF WEB APPLICATIONS</strong>[2]</h2>
<p><strong>Layered Architecture</strong>[2]</p>
<pre><code><span class="hljs-built_in">Client</span> (Browser) â† HTML rendering
        â†“ (Network)
Application <span class="hljs-built_in">Server</span> â† Business logic
        â†“ (Network)
Database <span class="hljs-built_in">Server</span> â† Data storage
</code></pre><p><strong>Advantages of Layering</strong>[2]
âœ“ Change one layer without affecting others
âœ“ Business logic independent from UI
âœ“ Database system can be changed independently
âœ“ Greater flexibility and simplicity</p>
<p><strong>Types of Web Applications</strong>[2]</p>
<ul>
<li>Static text content</li>
<li>Frequently changed content</li>
<li>Interactive websites (user input)</li>
<li>Portals/gateways</li>
<li>E-commerce/transaction sites</li>
<li>Search engines</li>
</ul>
<hr>
<h2 id="-9-2-2-development-testing-deployment-2-"><strong>9.2.2 DEVELOPMENT, TESTING, DEPLOYMENT</strong>[2]</h2>
<p><strong>Development Challenges</strong>[2]</p>
<table>
<thead>
<tr>
<th>Challenge</th>
<th>Detail</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Network Element</strong></td>
<td>Variable speeds, unreliable connections</td>
</tr>
<tr>
<td><strong>Race Conditions</strong></td>
<td>Timing issues in distributed environment</td>
</tr>
<tr>
<td><strong>Lost Connections</strong></td>
<td>Users disconnecting unexpectedly</td>
</tr>
<tr>
<td><strong>Timeouts</strong></td>
<td>Long waits, network fluctuations</td>
</tr>
<tr>
<td><strong>Scalability</strong></td>
<td>Must handle large concurrent user loads</td>
</tr>
<tr>
<td><strong>Machine Sizing</strong></td>
<td>Proper resource allocation needed</td>
</tr>
</tbody>
</table>
<p><strong>Testing Challenges</strong>[2]</p>
<ul>
<li>Hard to simulate real internet conditions (test labs use LAN)</li>
<li>Variable response times</li>
<li>Must obtain best, average, worst-case times</li>
<li><strong>Browser Compatibility Issues</strong>:<ul>
<li>Different operating systems (Linux, Windows, Unix)</li>
<li>Different OS versions</li>
<li>Java Virtual Machine differences</li>
<li>Browser extensions &amp; incomplete standards adherence</li>
<li>Bugs in specific browser/OS combinations</li>
</ul>
</li>
<li>Automated testing crucial for load/performance/stress tests</li>
<li>Impractical to test all combinations â†’ fix bugs during field use</li>
</ul>
<p><strong>Deployment Challenges</strong>[2]</p>
<ul>
<li>Limited ability to control access (unlike conventional apps)</li>
<li>Conflict: Small test group vs. realistic testing requirements</li>
<li>Must handle large concurrent user base</li>
<li><strong>Storage Scalability</strong>: Risk of running out of space</li>
<li><strong>Bandwidth</strong>: Server can be swamped by user requests</li>
</ul>
<hr>
<h2 id="-9-2-3-usage-of-web-applications-2-"><strong>9.2.3 USAGE OF WEB APPLICATIONS</strong>[2]</h2>
<p><strong>User Characteristics</strong>[2]</p>
<ul>
<li>Lay users with little computer knowledge</li>
<li>Cannot provide training/help desk support</li>
<li>Users exercise software in unexpected ways</li>
<li><strong>Exceptionally low tolerance level</strong>:<ul>
<li>Will abandon if page doesn&#39;t work in few seconds</li>
<li>Will not return if network breaks during use</li>
<li>No complaint, just disappear</li>
</ul>
</li>
</ul>
<p><strong>User Expectations</strong>[2]</p>
<ul>
<li>Fast response (few seconds maximum)</li>
<li>Feedback on request status</li>
<li>Instructions for disconnection handling</li>
<li><strong>Internationalization</strong>: Multi-language, multi-cultural support</li>
<li><strong>Data Entry Minimization</strong>: Auto-completion, dropdowns, lookup tables</li>
</ul>
<hr>
<h2 id="-9-2-4-maintaining-web-applications-2-"><strong>9.2.4 MAINTAINING WEB APPLICATIONS</strong>[2]</h2>
<p><strong>Maintenance Challenges</strong>[2]</p>
<ul>
<li><strong>Frequent presentation changes</strong>: Look &amp; feel updates expected</li>
<li><strong>Content volatility</strong>: Daily or hourly updates in some sites</li>
<li><strong>Business logic changes</strong>: New schemes/packages invented frequently</li>
<li><strong>Trend sensitivity</strong>: Site perceived as outdated if not changed for months</li>
<li><strong>Usability improvement</strong>: Major effort beyond bug fixes</li>
</ul>
<p><strong>Maintenance Tasks</strong>[2]
âœ“ Update static text pages
âœ“ Change business logic with minimal other layer changes
âœ“ Enhance user interface features
âœ“ Improve visual appeal
âœ“ Maintain current/trendy appearance</p>
<hr>
<h2 id="-9-2-5-designing-web-applications-2-"><strong>9.2.5 DESIGNING WEB APPLICATIONS</strong>[2]</h2>
<p><strong>Design Principles</strong>[2]</p>
<ul>
<li>Layered design = simplified, easily maintained</li>
<li>Components must be generalized for broader audience</li>
<li>Application server provides framework &amp; beans</li>
</ul>
<p><strong>Web Services</strong>[2]</p>
<ul>
<li>Components on web that run with application</li>
<li>Advertise available functionality</li>
<li>Applications tap needed services</li>
<li>Increases reusability but adds security/reliability concerns</li>
</ul>
<p><strong>UI Design Importance</strong>[2]</p>
<ul>
<li>Often tipping point for website success</li>
<li>Must consider: Ease of use, ergonomics, accessibility</li>
<li>Support disparate skill levels</li>
<li>Provide access for people with disabilities</li>
</ul>
<hr>
<h2 id="-9-3-1-good-software-development-practices-2-"><strong>9.3.1 GOOD SOFTWARE DEVELOPMENT PRACTICES</strong>[2]</h2>
<p><strong>Managing Requirements</strong>[2]</p>
<ul>
<li>Clear understanding with customer essential</li>
<li>Regular communication vital</li>
<li>Document requirements thoroughly</li>
<li>Understand finer points through coordination</li>
<li><strong>Track requirement changes</strong> throughout project</li>
<li>Ensure artifacts reflect requirement changes</li>
</ul>
<p><strong>Project Plan Content</strong>[2]</p>
<ul>
<li>Background information &amp; context</li>
<li>Customer &amp; stakeholder information</li>
<li>Cost, effort, duration estimates</li>
<li>Dependencies on outside groups</li>
<li>Resource requirements (equipment &amp; people)</li>
<li>Methodology</li>
<li>Monitoring approach</li>
<li>Schedule</li>
</ul>
<p><strong>Subordinate Plans</strong>[2]</p>
<ul>
<li>Configuration Management Plan</li>
<li>Quality Assurance Plan (audits, compliance)</li>
<li>Quality Control Plan (reviews, testing)</li>
<li>Risk Management Plan</li>
<li>Training Plan</li>
<li>Metrics Plan</li>
<li>Defect Prevention Plan</li>
</ul>
<p><strong>Team Communication</strong>[2]</p>
<ul>
<li>Shared vision &amp; sense of purpose</li>
<li>Perceptions aligned to project goals</li>
<li>Regular monitoring of progress</li>
<li>Effort, cost, quality tracking</li>
<li>Corrective action when off-plan</li>
<li>Plan review &amp; revision when needed</li>
</ul>
<p><strong>Configuration Management</strong>[2]</p>
<ul>
<li>Track all artifact versions</li>
<li>Know current vs. obsolete versions</li>
<li>Don&#39;t discard obsolete versions (may need to backtrack)</li>
<li>Place artifacts in baseline area</li>
<li>Formal change procedures for all changes</li>
<li>Limited access to designated controller</li>
<li>Check-out process before modification</li>
<li>Handle conflicting changes if simultaneous checkouts</li>
</ul>
<p><strong>Measurements</strong>[2]</p>
<ul>
<li>Key to project control</li>
<li>Objective progress assessment</li>
<li>Avoid intuition-based decisions</li>
<li>Enable informed decisions</li>
</ul>
<p><strong>Risk Management</strong>[2]</p>
<ul>
<li>Identify possible risks early</li>
<li>Focus on high-probability &amp; high-impact risks</li>
<li>Cannot eliminate all risks</li>
<li>Reduce risk effects</li>
<li>Prevent risks becoming reality</li>
<li>Continuously re-examine &amp; update risk plan</li>
<li>Active rather than reactive approach</li>
</ul>
<hr>
<h2 id="-9-3-2-web-application-team-structure-2-"><strong>9.3.2 WEB APPLICATION TEAM STRUCTURE</strong>[2]</h2>
<p><strong>Webmaster</strong>[2]</p>
<ul>
<li><strong>Role</strong>: Day-to-day site administration</li>
<li><strong>Activities</strong>:<ul>
<li>Gather user feedback (bugs, suggestions, questions)</li>
<li>Ensure access control &amp; security</li>
<li>Obtain usage statistics:<ul>
<li>Number of hits (by IP address)</li>
<li>Registered visitors</li>
<li>Page visit frequency distribution</li>
<li>Bandwidth usage (upload/download)</li>
<li>Error counts &amp; types (service denials)</li>
</ul>
</li>
<li>Ensure change control procedures followed</li>
<li>Archive old content, highlight new content</li>
</ul>
</li>
</ul>
<p><strong>Application Support Team</strong>[2]</p>
<ul>
<li><strong>Key Difference</strong>: Maintaining developed site is organization&#39;s responsibility</li>
<li><strong>Why</strong>: Web apps continuously evolve; development phase brief; evolution happens post-launch</li>
<li><strong>Team Composition</strong>: Designers, graphic artists, programmers, database specialists, testers</li>
<li><strong>Activities</strong>:<ul>
<li>Remove bugs &amp; cosmetic irritants</li>
<li>Change UI for novelty &amp; user feedback</li>
<li>Alter business rules</li>
<li>Introduce new features &amp; schemes</li>
<li>Disable/remove older features</li>
</ul>
</li>
</ul>
<hr>
<h2 id="-9-5-analysis-2-"><strong>9.5 ANALYSIS</strong>[2]</h2>
<p><strong>Key Considerations</strong>[2]</p>
<ul>
<li>Elicit, represent, validate requirements</li>
<li>Identify process owner &amp; stakeholders</li>
<li>Avoid wish lists from unauthorized persons</li>
<li>Detailed system analysis from scope</li>
</ul>
<p><strong>User Interface Analysis</strong>[2]</p>
<ul>
<li>More critical than conventional apps</li>
<li>Must be simple, visually appealing</li>
<li>Forgiving of lay users</li>
<li>Support computers/software unfamiliar users</li>
</ul>
<p><strong>Content Strategy</strong>[2]</p>
<ul>
<li>What to show users (brochures, packages, offerings)</li>
<li>Eye-catching but not garish presentation</li>
<li>Users should benefit without elaborate actions</li>
</ul>
<p><strong>Target Audience Analysis</strong>[2]</p>
<ul>
<li><strong>Geographical region</strong></li>
<li><strong>Language, beliefs, culture</strong></li>
<li><strong>Social strata</strong></li>
<li><strong>Age group &amp; gender</strong></li>
<li>Customize design to appeal to typical visitor</li>
</ul>
<hr>
<h2 id="-9-6-design-and-construction-2-"><strong>9.6 DESIGN AND CONSTRUCTION</strong>[2]</h2>
<p><strong>Design Principles</strong>[2]</p>
<ul>
<li>Work similarly to conventional apps</li>
<li><strong>Reuse is imperative</strong> (compressed timescales, volatility)</li>
<li>Reuse: code, object libraries, design patterns</li>
</ul>
<p><strong>Application Server Framework</strong>[2]</p>
<ul>
<li>Provides framework for app execution</li>
<li>Handles mundane details (security, persistence)</li>
<li>Beans provide functionality (some purchased, some built)</li>
</ul>
<p><strong>User Interface Design Aspects</strong>[2]</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Detail</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Visual Appeal</strong></td>
<td>Clean, pleasant design; avoid garish effects; functionality &gt; aesthetics</td>
</tr>
<tr>
<td><strong>Data Entry</strong></td>
<td>Minimize keyboard input; use mouse selection; ask for info easily</td>
</tr>
<tr>
<td><strong>Response Ease</strong></td>
<td>Clear, interpretable results; visual feedback for processing; help available</td>
</tr>
<tr>
<td><strong>Intuitive Navigation</strong></td>
<td>Site maps, location indicators; single-click home return; app provides navigation</td>
</tr>
<tr>
<td><strong>Robustness</strong></td>
<td>Graceful error handling; no harsh disconnections; error explanations</td>
</tr>
<tr>
<td><strong>No Scrolling</strong></td>
<td>All content visible without scrolling (critical for non-programmers)</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-9-7-reviews-and-testing-2-"><strong>9.7 REVIEWS AND TESTING</strong>[2]</h2>
<p><strong>Content Review</strong>[2]</p>
<ul>
<li>Check for factual &amp; language errors</li>
<li>Review navigation ease</li>
<li>Identify data entry difficulties</li>
</ul>
<p><strong>Unit Testing</strong>[2]</p>
<ul>
<li><strong>Web Page</strong> = smallest testable unit (not individual program)</li>
<li>Test: Content, navigation, links to other pages</li>
<li>No broken links</li>
<li>Functionality works correctly</li>
</ul>
<p><strong>Integration Testing</strong>[2]</p>
<ul>
<li>How pages work together</li>
<li>Repeat tests after bug fixes</li>
<li>Ensure fix doesn&#39;t cause new problems</li>
</ul>
<p><strong>System Testing</strong>[2]</p>
<ul>
<li>Individual pages work well</li>
<li>Pages work well together</li>
<li>No hidden issues</li>
</ul>
<p><strong>Browser/OS Testing Challenges</strong>[2]</p>
<ul>
<li>Cannot test all browser/OS combinations</li>
<li>Document tested combinations</li>
<li>Fix bugs reported during field use</li>
</ul>
<p><strong>Configuration Requirements</strong>[2]</p>
<ul>
<li>Screen resolutions (horizontal scroll most irritating)</li>
<li>Network speeds (test at lowest expected speed)</li>
<li>Deployment environment configuration</li>
</ul>
<hr>
<hr>
<h1 id="-unit-10-mobile-software-engineering-3-"><strong>UNIT 10: MOBILE SOFTWARE ENGINEERING</strong>[3]</h1>
<h2 id="-10-2-transition-from-design-to-coding-3-"><strong>10.2 TRANSITION FROM DESIGN TO CODING</strong>[3]</h2>
<p><strong>10.2.1 Create a Transition</strong>[3]</p>
<ul>
<li><strong>Transition</strong>: Holds information about animations during scene change</li>
<li><strong>Two main jobs</strong>:<ol>
<li>Capture property values</li>
<li>Play animations based on property changes</li>
</ol>
</li>
<li>Specify built-in or create custom transitions in code</li>
</ul>
<p><strong>10.2.2 Wireframes</strong>[3]</p>
<ul>
<li><strong>Purpose</strong>: Show functionalities, user interactions, screen flows without specifying actual appearance</li>
<li><strong>Android Wireframes</strong>: Screen sketches of Android apps</li>
<li><strong>Benefits</strong>: Present design ideas to customers, build consensus</li>
</ul>
<p><strong>10.2.3 Prototyping Mobile UI Animations</strong>[3]</p>
<ul>
<li>Animations guide users through experience</li>
<li>Should be relevant, targeted, purposeful</li>
<li>Effects: popping, fading, sliding, folding, dropping, bouncing</li>
<li>Avoid animating for animation&#39;s sake</li>
</ul>
<p><strong>10.2.4 Wireframing Features</strong>[3]</p>
<ul>
<li>Behaviors like real app</li>
<li>Get real user feedback</li>
<li>Accelerate innovation</li>
<li>Avoid rework</li>
<li>MVP (Minimum Viable Product) created for client feedback</li>
</ul>
<p><strong>10.2.5 Animate Layout Changes</strong>[3]</p>
<p><strong>Transition Framework Features</strong>[3]</p>
<ul>
<li>Group-level animations (multiple effects on view hierarchies)</li>
<li>Built-in animations (fade, movement)</li>
<li>Resource file support (load from layout files)</li>
<li>Lifecycle callbacks (control animation phases)</li>
</ul>
<p><strong>Animation Process</strong>[3]</p>
<ol>
<li>Create Scene for starting layout</li>
<li>Create Scene for ending layout</li>
<li>Create Transition object (define animation type)</li>
<li>Call TransitionManager.go() â†’ system animates</li>
</ol>
<p><strong>10.2.6 Apply a Transition</strong>[3]</p>
<p><strong>Enter Transitions</strong> (views entering scene)[3]</p>
<ul>
<li><strong>Explode</strong>: Views enter from outside, fly toward center</li>
<li><strong>Slide</strong>: Move in from edges</li>
<li><strong>Fade</strong>: Add view by changing opacity</li>
</ul>
<p><strong>Exit Transitions</strong> (views leaving scene)[3]</p>
<ul>
<li><strong>Explode</strong>: Views exit away from center</li>
<li><strong>Slide</strong>: Move out from edges</li>
<li><strong>Fade</strong>: Remove by opacity change</li>
</ul>
<p><strong>Shared Elements Transitions</strong> (between activities)[3]</p>
<ul>
<li><strong>changeBounds</strong>: Animate layout bounds changes</li>
<li><strong>changeClipBounds</strong>: Animate clip bounds changes</li>
<li><strong>changeTransform</strong>: Animate scale &amp; rotation</li>
<li><strong>changeImageTransform</strong>: Animate image size &amp; scale</li>
</ul>
<p><strong>10.2.7 Wireframe Best Practices</strong>[3]</p>
<ul>
<li>Keep simple for quick production &amp; discarding</li>
<li>Low-fidelity presentation for clarity</li>
<li>Don&#39;t beautify drawings excessively</li>
<li>Use placeholder text (not actual content)</li>
<li>Use annotations sparingly</li>
<li>Tools better than hand-drawn (state, storyboard, version control)</li>
</ul>
<p><strong>10.2.8 Benefits of Wireframing</strong>[3]</p>
<ol>
<li><strong>Clarify User Interface</strong></li>
<li><strong>Early Usability Consideration</strong></li>
<li><strong>Engage Clients</strong></li>
<li><strong>Cost-Efficient</strong> (inexpensive to create/edit, avoids costly rework)</li>
</ol>
<hr>
<h2 id="-10-3-elements-of-mobile-applications-20-key-aspects-3-"><strong>10.3 ELEMENTS OF MOBILE APPLICATIONS (20 Key Aspects)</strong>[3]</h2>
<p><strong>10.3.1 Product Strategy</strong>[3]</p>
<ul>
<li>Thorough strategy solving immediate business goals</li>
<li>Address long-term growth opportunities</li>
<li>Choose high-impact opportunities</li>
<li>Project analysis &amp; prioritization techniques</li>
<li>Deliver intentional, measurable business value</li>
</ul>
<p><strong>10.3.2 Comprehending Application Needs</strong>[3]</p>
<ul>
<li>Understand business aspects to cover</li>
<li>Place business priorities through app</li>
<li>Long-term success depends on alignment</li>
</ul>
<p><strong>10.3.3 User Interface Design (UI)</strong>[3]</p>
<ul>
<li>Subsets of user experience design</li>
<li>Create decent, useful features</li>
<li>Usability crucial</li>
</ul>
<p><strong>10.3.4 Screen Resolution</strong>[3]</p>
<ul>
<li>Consider various device screens</li>
<li>Right pixels-per-inch or standard resolution</li>
<li>Check application store guidelines</li>
<li>Responsive across devices</li>
</ul>
<p><strong>10.3.5 Graphics Must Be Appealing</strong>[3]</p>
<ul>
<li>Appearance vital</li>
<li>Graphics determine success/failure</li>
<li>Auto-adjust to all screen sizes</li>
<li>High-quality images, animations, visuals</li>
<li>&quot;Picture worth thousand words&quot;</li>
</ul>
<p><strong>10.3.6 User Experience Design (UX)</strong>[3]</p>
<ul>
<li>Create positive emotions &amp; attitudes</li>
<li>How users <em>feel</em> using app</li>
<li><strong>UX vs UI</strong>: UX = user retention (subjective), UI = visuals/graphics (technical)</li>
<li>UX is 2-part: <ol>
<li>Scientific understanding of user problems</li>
<li>Well-articulated UX strategy</li>
</ol>
</li>
<li>Intuitive, interactive designs</li>
</ul>
<p><strong>10.3.7 Good Speed</strong>[3]</p>
<ul>
<li>Most critical element</li>
<li>Hanging/stuck app = users annoyed &amp; leave</li>
<li>No one waits for slow apps</li>
<li>Simple, easy, quick solutions demanded</li>
</ul>
<p><strong>10.3.8 User-Friendly Navigation</strong>[3]</p>
<ul>
<li>Poor navigation = low user patience</li>
<li>Simple app for easy finding</li>
<li>Clutter-free experience</li>
<li>Simplicity &gt; complexity (ultimate sophistication)</li>
<li>Don&#39;t waste user time on exploration</li>
</ul>
<p><strong>10.3.9 Application Content</strong>[3]</p>
<ul>
<li>Explicit, precise content</li>
<li>Text for labels, guidelines, terminology</li>
<li>Don&#39;t stuff keywords (SEO distorts message)</li>
<li>Updated content looks fresh</li>
<li>3 factors for mobile development:<ol>
<li>Quality of experience desired</li>
<li>Feature complexity needed</li>
<li>Budget</li>
</ol>
</li>
</ul>
<p><strong>10.3.10 Mobile Device Performance</strong>[3]</p>
<p><strong>Size</strong></p>
<ul>
<li>Limited storage capacity</li>
<li>Well-designed app consumes less space</li>
<li>Keeps CPU/RAM free</li>
<li>Enables fast loading</li>
</ul>
<p><strong>Battery &amp; Processor Usage</strong></p>
<ul>
<li>Some apps overwork processor (gaming apps)</li>
<li>Design to minimize energy consumption</li>
<li>Longer battery life expected</li>
</ul>
<p><strong>10.3.11 Social Sharing Option</strong>[3]</p>
<ul>
<li>Integrate with popular social networks</li>
<li>Built-in viral mechanism</li>
<li>Users market app for you</li>
</ul>
<p><strong>10.3.12 Security</strong>[3]</p>
<ul>
<li>Most crucial factor</li>
<li>Encrypt user information &amp; data</li>
<li>Make users safe</li>
</ul>
<p><strong>10.3.13 Power Consumption</strong>[3]</p>
<ul>
<li>Affects device battery life</li>
<li>Avoid battery-draining resources</li>
<li>Optimize for maximum battery life</li>
</ul>
<p><strong>10.3.14 Compatibility</strong>[3]</p>
<ul>
<li>iOS &amp; Android version support</li>
<li>Updates as OS versions change</li>
<li>Unique features for different versions</li>
<li>Keep users engaged</li>
</ul>
<p><strong>10.3.15 Simplicity</strong>[3]</p>
<ul>
<li>Increasingly demanded</li>
<li>Not all users are experts</li>
<li>Ease of use improves success chances</li>
<li>Easier, simpler, quicker</li>
</ul>
<p><strong>10.3.16 Offline Function</strong>[3]</p>
<ul>
<li>Usable without network coverage</li>
<li>Increased use in low-connectivity areas</li>
<li>Attracts users from developing countries</li>
</ul>
<p><strong>10.3.17 High Performance</strong>[3]</p>
<ul>
<li>Poorly performing apps abandoned</li>
<li>Performance = success gauge</li>
<li>Majority stop using after 2+ poor experiences</li>
<li>Extremely important component</li>
</ul>
<p><strong>10.3.18 Provide Feedback Option</strong>[3]</p>
<ul>
<li>Easy feedback pathway</li>
<li>Improves user experience</li>
<li>Helps address complaints</li>
<li>Device improvements through reviews</li>
</ul>
<p><strong>10.3.19 Regular Updates</strong>[3]</p>
<ul>
<li>Quality improvements</li>
<li>Add necessary features</li>
<li>Based on user experience &amp; reviews</li>
<li>Frequent updates improve rating</li>
<li>Address suggestions &amp; complaints</li>
</ul>
<p><strong>10.3.20 Marketing</strong>[3]</p>
<ul>
<li>Never underestimate importance</li>
<li>People must know about app</li>
<li>Poor marketing = failure despite good app</li>
<li>Convey message to users, customers, clients</li>
</ul>
<hr>
<h2 id="-10-4-development-approaches-3-"><strong>10.4 DEVELOPMENT APPROACHES</strong>[3]</h2>
<p><strong>10.4.1 Native Application Development</strong>[3]</p>
<ul>
<li><strong>Platform-specific</strong> programming languages, SDKs, environments</li>
<li>Separate development for each platform (iOS â‰  Android)</li>
</ul>
<p><strong>Native iOS Stack</strong>[3]</p>
<p><strong>Objective-C</strong></p>
<ul>
<li>High-level, object-oriented language</li>
<li>C-like, dynamic runtime</li>
<li>Still widely used despite Swift</li>
<li>Advantages: Works with C++, well-tested, expressive syntax, private APIs, multiple libraries, large community</li>
</ul>
<p><strong>Swift</strong></p>
<ul>
<li>Multi-purpose, multi-paradigm language</li>
<li>Open-source</li>
<li>Less error-prone code</li>
<li>Dynamic libraries (reduce app size, boost performance)</li>
<li>Simplifies development &amp; maintenance</li>
<li>Enhanced code reusability &amp; readability</li>
<li>Advantages: Multi-feature, fast performance, Objective-C compatible, Cocoa Touch/Cocoa frameworks, multi-device, community support</li>
</ul>
<p><strong>Advantages of Native Development</strong>[3]
âœ“ Best performance overall
âœ“ Platform-specific UI implementation
âœ“ 100% OS feature support
âœ“ Total hardware feature access
âœ“ Clear update path &amp; supported toolset
âœ“ Highly reliable, secure, responsive</p>
<p><strong>Prime Reasons to Choose Native</strong>[3]</p>
<ol>
<li>Complete device feature access</li>
<li>Scalability</li>
<li>Offline performance</li>
<li>Stability</li>
<li>Cost</li>
</ol>
<p><strong>10.4.2 Cross-Platform Application Development</strong>[3]</p>
<ul>
<li>Single codebase for multiple platforms</li>
<li>Advantages: Faster development, lower cost, code reuse</li>
<li>Trade-off: May not utilize all platform features</li>
</ul>
<p><strong>10.4.3 Hybrid Application Development</strong>[3]</p>
<ul>
<li>Combines native &amp; web technologies</li>
<li>Platform-specific shell with web content</li>
<li>Advantages: Faster development, cost-effective, moderate performance</li>
</ul>
<p><strong>10.4.4 Rapid Mobile Application Development (RMAD)</strong>[3]</p>
<ul>
<li><strong>Low-code/No-code approach</strong></li>
<li>Code-free development</li>
<li>Little developer experience needed</li>
<li>Reusable components</li>
</ul>
<p><strong>Advantages of RMAD</strong>[3]
âœ“ Secure
âœ“ Works online &amp; offline
âœ“ Good backend data integration
âœ“ All platforms including web
âœ“ Code-free development
âœ“ Minimal developer experience required
âœ“ Reusable components
âœ“ Low cost of production</p>
<p><strong>10.4.5 Progressive Web Applications (PWAs)</strong>[3]</p>
<ul>
<li>HTML primary engagement</li>
<li><strong>Merge web &amp; native app worlds</strong></li>
<li>Native app-like web applications</li>
</ul>
<p><strong>Advantages of PWAs</strong>[3]
âœ“ Easy maintenance
âœ“ Single codebase
âœ“ Mobile-friendly UI
âœ“ No app store hosting needed
âœ“ Works online &amp; offline</p>
<hr>
<h2 id="-decision-framework-3-"><strong>DECISION FRAMEWORK</strong>[3]</h2>
<p><strong>When to Choose Each Approach</strong>[3]</p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Best For</th>
<th>Time</th>
<th>Cost</th>
<th>Quality</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Native</strong></td>
<td>Long-term, responsive, superior quality, security</td>
<td>Longer</td>
<td>Higher</td>
<td>Best</td>
</tr>
<tr>
<td><strong>Cross-Platform</strong></td>
<td>Budget compromise, faster development</td>
<td>Medium</td>
<td>Medium</td>
<td>Good</td>
</tr>
<tr>
<td><strong>Hybrid</strong></td>
<td>Quick development, multiple platforms</td>
<td>Fast</td>
<td>Lower</td>
<td>Fair</td>
</tr>
<tr>
<td><strong>RMAD</strong></td>
<td>Non-technical users, rapid deployment</td>
<td>Very Fast</td>
<td>Very Low</td>
<td>Good</td>
</tr>
<tr>
<td><strong>PWA</strong></td>
<td>Web-first, offline support, multi-platform</td>
<td>Medium</td>
<td>Lower</td>
<td>Good</td>
</tr>
</tbody>
</table>
<hr>

<p>Perfect! Now I have all three units. Let me create a comprehensive summary in the same pattern as the previous response.</p>
<hr>
<h1 id="comprehensive-summary-units-11-12-and-13">COMPREHENSIVE SUMMARY: UNITS 11, 12, AND 13</h1>
<hr>
<h1 id="-unit-11-case-tools-1-"><strong>UNIT 11: CASE TOOLS</strong>[1]</h1>
<h2 id="-11-2-what-are-case-tools-1-"><strong>11.2 WHAT ARE CASE TOOLS?</strong>[1]</h2>
<p><strong>Definition</strong>[1]</p>
<ul>
<li><strong>Computer Aided Software Engineering (CASE) tools</strong> are software engineering tools that permit collaborative software development and maintenance</li>
<li>Support almost all phases of Software Development Life Cycle (SDLC) including: analysis, design, implementation, testing</li>
<li>Support umbrella activities: project management, configuration management</li>
</ul>
<p><strong>Key Functions</strong>[1]
âœ“ Support contemporary software development methods (Jackson programming, structured system analysis and design)
âœ“ Automate generation of database tables, forms, reports
âœ“ Generate user documentation automatically
âœ“ Improve software quality through consistency and coordination
âœ“ Create organization-wide environment minimizing repetitive work
âœ“ Support quality documentation (completeness, non-ambiguity)
âœ“ Provide automated checking in testing process</p>
<hr>
<h2 id="-11-2-1-categories-of-case-tools-1-"><strong>11.2.1 CATEGORIES OF CASE TOOLS</strong>[1]</h2>
<p><strong>Upper CASE Tools</strong>[1]</p>
<ul>
<li>Focus on <strong>analysis and design phases</strong></li>
<li>Include: modeling tools, reports/forms generation, documentation generators</li>
<li>Works with high-level requirements specifications</li>
</ul>
<p><strong>Lower CASE Tools</strong>[1]</p>
<ul>
<li>Support <strong>implementation phase</strong></li>
<li>Include: code generators, compilers, linkers, debuggers, interpreters</li>
<li>Works with programming languages and code</li>
</ul>
<p><strong>Integrated CASE Tools</strong>[1]</p>
<ul>
<li>Provide <strong>linkages between upper and lower CASE</strong></li>
<li>Create cohesive environment where design automatically generates code</li>
<li>Enable smooth transition from analysis to implementation</li>
</ul>
<p><strong>Types of Tools in CASE Environment</strong>[1]</p>
<ul>
<li>Analysis tools</li>
<li>Diagramming tools</li>
<li>Screen and report generators</li>
<li>Code generators</li>
<li>Documentation generators</li>
<li>Reverse engineering tools (extract design from code)</li>
<li>Re-engineering tools (alter system to improve quality)</li>
</ul>
<hr>
<h2 id="-11-2-2-need-of-case-tools-1-"><strong>11.2.2 NEED OF CASE TOOLS</strong>[1]</h2>
<p><strong>Organizational Benefits</strong>[1]
âœ“ <strong>Reduce cost</strong> â€” automate repetitive manual tasks
âœ“ <strong>Reduce development time</strong> â€” support standardization, avoid repetition, enable reuse
âœ“ <strong>Develop better quality</strong> â€” provide greater consistency and coordination
âœ“ <strong>Create good documentation</strong> â€” automatic quality documentation generation
âœ“ <strong>Maintainable systems</strong> â€” proper configuration control and traceability of requirements</p>
<p><strong>What CASE Tools CANNOT Do</strong>[1]
âœ— Automatically develop functionally relevant systems
âœ— Force system analysts to follow prescribed methodology
âœ— Change system analysis and design process fundamentally
âœ— Automate all project management problems (many are not amenable to automation)</p>
<p><strong>Disadvantages of CASE Tools</strong>[1]</p>
<ul>
<li>Complex functionality requires training</li>
<li>Cannot address all project management issues</li>
<li>Many implementation challenges</li>
</ul>
<hr>
<h2 id="-11-2-3-factors-affecting-case-deployment-in-organization-1-"><strong>11.2.3 FACTORS AFFECTING CASE DEPLOYMENT IN ORGANIZATION</strong>[1]</h2>
<p><strong>Critical Success Factors</strong>[1]
âœ“ Training all users in CASE environment and benefits
âœ“ Compulsory initial use by developers
âœ“ Closeness of CASE methodology to SDLC
âœ“ Compatibility with other development platforms in organization
âœ“ Timely vendor support and low-cost support
âœ“ Easy to use with low complexity and online help
âœ“ Good graphic support and multiple user support</p>
<hr>
<h2 id="-11-2-4-characteristics-of-successful-case-tools-1-"><strong>11.2.4 CHARACTERISTICS OF SUCCESSFUL CASE TOOLS</strong>[1]</h2>
<p><strong>Essential Characteristics</strong>[1]</p>
<table>
<thead>
<tr>
<th>Characteristic</th>
<th>Detail</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Standard Methodology</strong></td>
<td>Support UML and standard development methodologies</td>
</tr>
<tr>
<td><strong>Flexibility</strong></td>
<td>Offer choice of editors and development environments</td>
</tr>
<tr>
<td><strong>Strong Integration</strong></td>
<td>All stages integrated â€” changes reflected across documents</td>
</tr>
<tr>
<td><strong>Testing Integration</strong></td>
<td>Interfaces with automatic testing tools for regression testing</td>
</tr>
<tr>
<td><strong>Reverse Engineering</strong></td>
<td>Generate complex models from existing code</td>
</tr>
<tr>
<td><strong>Online Help</strong></td>
<td>Provide tutorials and documentation</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>Visible/changeable only by authorized users</td>
</tr>
<tr>
<td><strong>Version Control</strong></td>
<td>Track various products and versions</td>
</tr>
<tr>
<td><strong>Import/Export</strong></td>
<td>Compatible data exchange from external resources</td>
</tr>
<tr>
<td><strong>Backup &amp; Recovery</strong></td>
<td>Protect precious data and repository</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-11-3-case-software-development-environment-1-"><strong>11.3 CASE SOFTWARE DEVELOPMENT ENVIRONMENT</strong>[1]</h2>
<p><strong>Functional Features</strong>[1]
âœ“ Create software requirements specifications
âœ“ Create cross-references
âœ“ Verify/analyze requirement-design relationships
âœ“ Perform project and configuration management
âœ“ Create design specifications
âœ“ Build system prototypes
âœ“ Contain code and accompanying documents
âœ“ Validation and verification
âœ“ Interface with external environment</p>
<p><strong>Major Features Required</strong>[1]</p>
<ul>
<li>Strong visual support</li>
<li>Prediction and error reporting</li>
<li>Content repository support</li>
<li>Structured methodology support</li>
<li>Integration of lifecycle stages</li>
<li>Consistent information transfer across SDLC</li>
<li>Automated coding/prototype generation</li>
</ul>
<p><strong>CASE and Web Engineering</strong>[1]</p>
<ul>
<li>Site content management tools</li>
<li>Site version control tools</li>
<li>Server management tools</li>
<li>Site optimization tools</li>
<li>Web authoring and deployment tools</li>
<li>Site testing tools (load/performance)</li>
<li>Link checkers and program checkers</li>
<li>Web security test tools</li>
</ul>
<hr>
<h2 id="-11-4-case-tools-and-requirement-engineering-1-"><strong>11.4 CASE TOOLS AND REQUIREMENT ENGINEERING</strong>[1]</h2>
<p><strong>Four-Step Requirements Engineering Process</strong>[1]</p>
<pre><code><span class="hljs-attribute">Requirement</span> Elicitation â†’ Requirements Specification â†’ 
Validation â†’ Requirements Management
</code></pre><p><strong>Requirement Elicitation Features</strong>[1]
âœ“ Dynamic, rich editing environment for team collaboration
âœ“ Centralized repository for requirements
âœ“ Task-driven workflow
âœ“ Change management and defect tracking
âœ“ Reusable requirements/design templates
âœ“ Track important system attributes (performance, security)
âœ“ Common vocabulary highlighting
âœ“ Quality assessment of requirements
âœ“ Glossary for ambiguous terms</p>
<p><strong>Requirements Specification Features</strong>[1]
âœ“ Labeled requirements document for traceability
âœ“ Support functional and non-functional requirements
âœ“ Quality attributes mapping
âœ“ Model creation for functional requirements
âœ“ Test case development for requirement verification
âœ“ Design and implementation traceability</p>
<p><strong>Requirement Validation Features</strong>[1]
âœ“ Customizable workflows
âœ“ Approvals and electronic signatures
âœ“ Audit trails
âœ“ Requirement ownership assignment</p>
<p><strong>Requirement Management Features</strong>[1]
âœ“ Visibility for controlling software delivery
âœ“ Effort and cost estimation
âœ“ Project schedule specification
âœ“ Quality parameter specification</p>
<p><strong>Change Management Features</strong>[1]
âœ“ Track changes and impact analysis
âœ“ Support requirements baselining
âœ“ Track type, status, priority, change history
âœ“ Bi-directional traceability
âœ“ Better communication than static documents</p>
<hr>
<h2 id="-11-5-case-tools-and-design-implementation-1-"><strong>11.5 CASE TOOLS AND DESIGN/IMPLEMENTATION</strong>[1]</h2>
<p><strong>Design Support Features</strong>[1]
âœ“ Structured Charts
âœ“ Program Design Language (PDL)
âœ“ ER model optimization
âœ“ Flowcharts
âœ“ Database design tools
âœ“ File design tools
âœ“ Testing and debugging items
âœ“ Error-checking stages
âœ“ Completeness and consistency checks
âœ“ Cross-reference verification</p>
<p><strong>Modeling Support</strong>[1]
âœ“ Continuously synchronized models and code
âœ“ Consistent information understanding
âœ“ Source code management through visual models
âœ“ Code refactoring capabilities
âœ“ Pattern implementation support
âœ“ Reverse engineering for legacy systems</p>
<p><strong>Standard Models Required</strong>[1]</p>
<ul>
<li>Overall system architecture</li>
<li>Software dependencies</li>
<li>Information flow</li>
<li>Database organization</li>
<li>Deployment configuration</li>
</ul>
<hr>
<h2 id="-11-5-case-repository-1-"><strong>11.5 CASE REPOSITORY</strong>[1]</h2>
<p><strong>Repository Contents</strong>[1]</p>
<ul>
<li>Data and process models</li>
<li>Rules and constraints</li>
<li>Data definitions and entities</li>
<li>Process documentation</li>
<li>Models (flow, state, data, UML)</li>
<li>Business rules and constraints</li>
</ul>
<p><strong>Primary Segments</strong>[1]</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Information Repository</strong></td>
<td>Organization&#39;s business information, applications</td>
</tr>
<tr>
<td><strong>Data Dictionary</strong></td>
<td>All data definitions, cross-references, aliases, descriptions, types, formats</td>
</tr>
</tbody>
</table>
<p><strong>Repository Advantages</strong>[1]
âœ“ Assists project management
âœ“ Enables software reusability
âœ“ Supports modular development
âœ“ Manages and controls access
âœ“ Stores in corporate database</p>
<hr>
<h2 id="-11-6-software-testing-and-case-tools-1-"><strong>11.6 SOFTWARE TESTING AND CASE TOOLS</strong>[1]</h2>
<p><strong>Features Needed for Testing</strong>[1]
âœ“ Support all testing phases (plan, manage, execute)
âœ“ Support all test types (functional, performance, integration, regression)
âœ“ Single interface for all testing
âœ“ Integration with third-party testing tools
âœ“ Local and remote test execution support
âœ“ Establish and manage requirement-test case traceability
âœ“ Automatic flag for impacted tests when requirements change
âœ“ Test run logging
âœ“ Meaningful reports on test completeness
âœ“ May provide automated testing</p>
<hr>
<h2 id="-11-7-software-quality-and-case-tools-1-"><strong>11.7 SOFTWARE QUALITY AND CASE TOOLS</strong>[1]</h2>
<p><strong>Quality Support Across All Phases</strong>[1]</p>
<table>
<thead>
<tr>
<th>Phase</th>
<th>CASE Support</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Analysis</strong></td>
<td>Reflect requirements clearly, accurately, simply</td>
</tr>
<tr>
<td><strong>Design</strong></td>
<td>Detect, isolate, resolve structural deficiencies</td>
</tr>
<tr>
<td><strong>Development</strong></td>
<td>Automatic runtime language tools for reliability</td>
</tr>
<tr>
<td><strong>Testing</strong></td>
<td>Automated testing for improved quality</td>
</tr>
<tr>
<td><strong>Deployment</strong></td>
<td>Prevent complete system failure on restart</td>
</tr>
</tbody>
</table>
<p><strong>Quality as Teamwork</strong>[1]
âœ“ Integration of workflow across individuals
âœ“ Traceability and communication establishment
âœ“ Sharing workload and configuration items</p>
<hr>
<h2 id="-11-8-software-configuration-management-and-case-1-"><strong>11.8 SOFTWARE CONFIGURATION MANAGEMENT AND CASE</strong>[1]</h2>
<p><strong>SCM Purpose</strong>[1]</p>
<ul>
<li>Controls deployment of new software versions</li>
<li>Manages distributed deployment automatically</li>
<li>Brings out releases efficiently and effectively</li>
<li>Reduces cost, risk, accelerates time</li>
</ul>
<p><strong>Required SCM Facilities</strong>[1]
âœ“ Configuration creation (documents software builds)
âœ“ Configuration lookup (rebuild only changed files)
âœ“ Dependency detection (even hidden dependencies)
âœ“ Team object sharing (save time)</p>
<p><strong>SCM Benefits</strong>[1]
âœ“ Automatic version control
âœ“ Access control
âœ“ Automatic rebuilding
âœ“ Build audit
âœ“ Maintenance and deployment</p>
<hr>
<h2 id="-11-9-software-project-management-and-case-tools-1-"><strong>11.9 SOFTWARE PROJECT MANAGEMENT AND CASE TOOLS</strong>[1]</h2>
<p><strong>CASE Features for Team Management</strong>[1]
âœ“ Sharing and securing projects (username/password)
âœ“ Reading project documents
âœ“ Exclusive document editing
âœ“ Document linking for sharing
âœ“ Automatic change request communication
âœ“ Revision label setting for versioning
âœ“ Addition/deletion indicators
âœ“ Automatic file update availability
âœ“ Version conflict reporting
âœ“ Version difference visualization
âœ“ Linked folder and change request access</p>
<p><strong>Project Management Tools Benefits</strong>[1]
âœ“ Control projects through tasks
âœ“ Track events and milestones
âœ“ Monitor progress via Gantt chart
âœ“ Web-based information
âœ“ Automatic notifications/emails</p>
<p><strong>Project Management Software Features</strong>[1]
âœ“ PERT and Gantt chart support
âœ“ Easy task entry and linking
âœ“ Milestone and critical path highlighting
âœ“ Edit capabilities (add/delete/move tasks)
âœ“ Timeline against calendar mapping
âœ“ Graphical task duration marking
âœ“ Task, resource, resource usage views
âœ“ Network usable and shareable</p>
<hr>
<hr>
<h1 id="-unit-12-advanced-topics-in-software-engineering-2-"><strong>UNIT 12: ADVANCED TOPICS IN SOFTWARE ENGINEERING</strong>[2]</h1>
<h2 id="-12-2-evolution-of-formal-methods-2-"><strong>12.2 EVOLUTION OF FORMAL METHODS</strong>[2]</h2>
<p><strong>Background</strong>[2]</p>
<ul>
<li>1970s: Structured programming revolution</li>
<li>Development of formal methods as unifying philosophy</li>
<li>Based on elementary mathematics</li>
<li>Produces precise, unambiguous documentation</li>
<li>Supports design process and guides development, testing, maintenance</li>
</ul>
<p><strong>Mathematical Applications in Software</strong>[2]</p>
<ul>
<li>Probability theory in performance modeling</li>
<li>Context-free grammars in compiler design</li>
<li>Relational calculus in database theory</li>
</ul>
<hr>
<h2 id="-12-3-use-of-mathematics-in-software-development-2-"><strong>12.3 USE OF MATHEMATICS IN SOFTWARE DEVELOPMENT</strong>[2]</h2>
<p><strong>Benefits of Mathematics</strong>[2]
âœ“ Supports abstraction â€” powerful medium for modeling
âœ“ Exact specifications â€” unambiguous and validated
âœ“ Uncover contradictions and incompleteness
âœ“ Validate specifications for functionality
âœ“ Demonstrate design matches specification
âœ“ Verify program code matches design</p>
<p><strong>Application Domains</strong>[2]</p>
<ul>
<li>Requirements phase</li>
<li>Design phase</li>
<li>Coding phase</li>
<li>Testing and maintenance</li>
</ul>
<p><strong>Mathematical Topics of Interest</strong>[2]</p>
<ul>
<li>Formal logic (propositional and predicate calculus)</li>
<li>Set theory</li>
<li>Formal languages</li>
<li>Automata (finite state machines)</li>
</ul>
<hr>
<h2 id="-12-4-formal-methods-2-"><strong>12.4 FORMAL METHODS</strong>[2]</h2>
<p><strong>Definition</strong>[2]</p>
<ul>
<li>Method providing formal language for software artifacts (specifications, designs, code)</li>
<li>Enables formal proofs about artifact properties</li>
<li>Two essential components: formal language + formal reasoning</li>
</ul>
<p><strong>Major Concerns</strong>[2]
âœ“ <strong>Correctness</strong> â€” produce correct software using rigorous mathematics
âœ“ <strong>Programs as Mathematical Objects</strong> â€” expressed in formal language with formal semantics
âœ“ <strong>Precise Specifications</strong> â€” support rigorous specifications
âœ“ <strong>Verification Support</strong> â€” construct formal proofs of implementation correctness</p>
<p><strong>Specification Goals</strong>[2]</p>
<table>
<thead>
<tr>
<th>Goal</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Ambiguity Removal</strong></td>
<td>Formal syntax enables single interpretation, eliminating natural language ambiguity</td>
</tr>
<tr>
<td><strong>Consistency</strong></td>
<td>Prevent contradictions through mathematical proof</td>
</tr>
<tr>
<td><strong>Completeness</strong></td>
<td>Define all aspects (difficult even with formal methods)</td>
</tr>
</tbody>
</table>
<p><strong>Well-Known Formal Methods</strong>[2]</p>
<ul>
<li><strong>Z</strong> (pronounced &quot;Zed&quot;)</li>
<li><strong>CSP</strong> â€” Communicating Sequential Processes</li>
<li><strong>VDM</strong> â€” Vienna Development Method</li>
<li><strong>Larch</strong></li>
<li><strong>FDM</strong> â€” Formal Development Methodology</li>
</ul>
<hr>
<h2 id="-12-4-1-what-can-be-formally-specified-2-"><strong>12.4.1 WHAT CAN BE FORMALLY SPECIFIED?</strong>[2]</h2>
<p><strong>Specification Techniques</strong>[2]</p>
<ul>
<li>Data Flow Diagrams (DFDs) â€” semi-formal method</li>
<li>Petri nets â€” fully formal, used in distributed systems</li>
<li>Finite state machines â€” formal in tabular form</li>
<li>Abstract Data Types (ADTs) â€” perfect for formal treatment</li>
</ul>
<p><strong>Application Levels</strong>[2]
âœ“ System specifications
âœ“ Design models
âœ“ Source code
âœ“ Hardware (VHDL descriptions)</p>
<hr>
<h2 id="-12-4-2-goals-of-formal-specification-2-"><strong>12.4.2 GOALS OF FORMAL SPECIFICATION</strong>[2]</h2>
<p><strong>Analysis Capabilities</strong>[2]
âœ“ Explore completeness and consistency
âœ“ Identify simultaneous states
âœ“ Verify all legal inputs yield one output
âœ“ Discover surprising/unintended results</p>
<p><strong>Verification Capabilities</strong>[2]
âœ“ Formal verification â€” construct proofs
âœ“ Dijkstra&#39;s weakest precondition calculus
âœ“ Harlan Mills functional correctness approach</p>
<hr>
<h2 id="-12-5-application-areas-for-formal-methods-2-"><strong>12.5 APPLICATION AREAS FOR FORMAL METHODS</strong>[2]</h2>
<p><strong>Primary Application Areas</strong>[2]
âœ“ Safety-critical systems
âœ“ Security systems
âœ“ Standards definition
âœ“ Hardware development
âœ“ Operating systems
âœ“ Transaction processing systems
âœ“ Hard, complex, or critical systems</p>
<p><strong>Emerging Research Areas</strong>[2]</p>
<ul>
<li>Fault tolerance</li>
<li>Response time</li>
<li>Space efficiency</li>
<li>Reliability</li>
<li>Human factors</li>
<li>Software structure dependencies</li>
</ul>
<hr>
<h2 id="-12-6-limitations-of-formal-specification-2-"><strong>12.6 LIMITATIONS OF FORMAL SPECIFICATION</strong>[2]</h2>
<p><strong>Technical Limitations</strong>[2]
âœ— Focus primarily on function and data
âœ— Difficult to represent timing, control, behavioral aspects
âœ— HCI and human-machine interface better specified graphically
âœ— More difficult to learn than other analysis methods</p>
<p><strong>Practical Limitations</strong>[2]</p>
<table>
<thead>
<tr>
<th>Limitation</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Cost</strong></td>
<td>Full specification as expensive as coding; specify only hard/critical subsystems</td>
</tr>
<tr>
<td><strong>Complexity</strong></td>
<td>Customers/users cannot read formal specs; needs extensive documentation</td>
</tr>
<tr>
<td><strong>Deficiencies</strong></td>
<td>Contradictions, ambiguities, vagueness, incompleteness, mixed abstraction levels</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-12-7-cleanroom-software-engineering-2-"><strong>12.7 CLEANROOM SOFTWARE ENGINEERING</strong>[2]</h2>
<p><strong>Definition</strong>[2]</p>
<ul>
<li>Iterative, life-cycle approach developed by Harlan Mills</li>
<li><strong>Focus</strong>: Software quality, especially reliability</li>
<li>Combines: formal specifications, structured programming, SPC, spiral lifecycle, inspections, reliability modeling</li>
<li><strong>Attitude</strong>: Emphasize defect prevention over defect removal</li>
</ul>
<p><strong>Cleanroom Results</strong>[2]
âœ“ Correct software by mathematically sound design
âœ“ Certified by statistically-valid testing
âœ“ Reduced cycle time (incremental strategy, avoided rework)
âœ“ Well-documented
âœ“ Early error detection
âœ“ Lower lifecycle costs than industry average</p>
<hr>
<h2 id="-12-9-cleanroom-principles-2-"><strong>12.9 CLEANROOM PRINCIPLES</strong>[2]</h2>
<p><strong>Three Core Principles</strong>[2]</p>
<table>
<thead>
<tr>
<th>Principle</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Incremental Development under SPC</strong></td>
<td>Iterative cycles compared with standards; return to design if quality not met</td>
</tr>
<tr>
<td><strong>Mathematical Software Development</strong></td>
<td>Computer programs as mathematical functions; Box Structure Method for specification/design; functional verification; correctness verification via team review</td>
</tr>
<tr>
<td><strong>Statistical Testing</strong></td>
<td>Software testing as statistical experiment; representative subset testing; scientifically valid statements about operational performance</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-12-9-cleanroom-development-strategy-2-"><strong>12.9 CLEANROOM DEVELOPMENT STRATEGY</strong>[2]</h2>
<p><strong>Phase-Wise Approach</strong>[2]</p>
<ol>
<li><strong>Increment Planning</strong> â€” project plan around incremental strategy</li>
<li><strong>Requirements Gathering</strong> â€” elicit and refine requirements per increment</li>
<li><strong>Box Structure Specification</strong> â€” isolate behavior, data, procedures at each refinement level</li>
<li><strong>Formal Design</strong> â€” iteratively refine black-boxes to architectural/component designs</li>
<li><strong>Code Generation &amp; Verification</strong> â€” translate boxes to code; inspect for conformance and correctness</li>
<li><strong>Statistical Test Planning</strong> â€” create test suite matching usage probability distribution</li>
</ol>
<p><strong>Team Roles</strong>[2]</p>
<ul>
<li>Specification team â€” develops and maintains system specification</li>
<li>Development team â€” develops and verifies software</li>
<li>Certification team â€” develops statistical tests; assesses reliability</li>
</ul>
<hr>
<h2 id="-12-8-cleanroom-vs-conventional-models-2-"><strong>12.8 CLEANROOM VS. CONVENTIONAL MODELS</strong>[2]</h2>
<p><strong>Key Differences</strong>[2]</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Cleanroom</th>
<th>Conventional</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Team Size</strong></td>
<td>Small (6-8 qualified professionals)</td>
<td>Larger teams</td>
</tr>
<tr>
<td><strong>Design Time</strong></td>
<td>Greater allocation to design phase</td>
<td>Less design time</td>
</tr>
<tr>
<td><strong>Integration</strong></td>
<td>Gradual, tuned to organization culture</td>
<td>Varies</td>
</tr>
<tr>
<td><strong>Example Projects</strong></td>
<td>IBM COBOLSF, Ericsson OS-32, USAF SCAI</td>
<td>Various models</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-12-12-software-reuse-and-component-based-engineering-2-"><strong>12.12 SOFTWARE REUSE AND COMPONENT-BASED ENGINEERING</strong>[2]</h2>
<p><strong>Software Reuse Goal</strong>[2]</p>
<ul>
<li>Build systems from standard components</li>
<li>Think in terms of system families</li>
<li>Apply OOP principles to whole development process</li>
<li>Focus on reusing and adapting existing components</li>
</ul>
<p><strong>Why Component-Based Engineering?</strong>[2]
âœ“ Increase productivity
âœ“ Improve quality
âœ“ Decrease time-to-market
âœ“ Build from existing, tested components</p>
<p><strong>Component Definition</strong>[2]</p>
<ul>
<li>Nontrivial, independent, replaceable system part</li>
<li>Fulfills clear function in well-defined architecture</li>
<li>Has interface with inheritance rules</li>
<li>Similar to OOP object concept</li>
</ul>
<hr>
<h2 id="-12-12-software-component-types-2-"><strong>12.12 SOFTWARE COMPONENT TYPES</strong>[2]</h2>
<p><strong>Component Categories</strong>[2]</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Characteristics</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>COTS</strong></td>
<td>Commercial off-the-shelf; pre-built; no source code; tested in many applications</td>
</tr>
<tr>
<td><strong>Qualified</strong></td>
<td>Tested and verified for requirements</td>
</tr>
<tr>
<td><strong>Adapted</strong></td>
<td>Modified/wrapped for compatibility</td>
</tr>
<tr>
<td><strong>Assembled</strong></td>
<td>Integrated into final product</td>
</tr>
<tr>
<td><strong>Updated</strong></td>
<td>Modified as requirements change</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-12-14-component-based-engineering-process-2-"><strong>12.14 COMPONENT-BASED ENGINEERING PROCESS</strong>[2]</h2>
<p><strong>CBSE Steps</strong>[2]</p>
<ol>
<li><strong>Requirements establishment</strong> â€” conventional elicitation</li>
<li><strong>Architectural design</strong> â€” define system architecture</li>
<li><strong>Component evaluation</strong> â€” assess suitability</li>
<li><strong>Requirement modification</strong> â€” adjust for available components</li>
<li><strong>Component qualification</strong> â€” verify performance, reliability, usability</li>
<li><strong>Component adaptation</strong> â€” wrap/modify for compatibility</li>
<li><strong>Component composition</strong> â€” integrate into operational system</li>
<li><strong>Component updating</strong> â€” maintain with configuration management</li>
</ol>
<p><strong>Key Questions</strong>[2]</p>
<ul>
<li>How to implement requirement?</li>
<li>Are COTS components available?</li>
<li>Are in-house reusable components available?</li>
<li>Are component interfaces compatible?</li>
</ul>
<hr>
<h2 id="-12-14-1-domain-engineering-2-"><strong>12.14.1 DOMAIN ENGINEERING</strong>[2]</h2>
<p><strong>Purpose</strong>[2]</p>
<ul>
<li>Identify, construct, catalogue, disseminate reusable components</li>
<li>Focus on specific application domains</li>
<li>Establish mechanisms for component sharing</li>
</ul>
<p><strong>Structural Modeling Approach</strong>[2]</p>
<ul>
<li>Pattern-based approach</li>
<li>Every application domain has repeating patterns</li>
<li>Patterns in function, data, behavior</li>
<li>Example: Aircraft avionics domain has standard structural model</li>
</ul>
<p><strong>Domain Engineering Steps</strong>[2]</p>
<ol>
<li>Identify domain to analyze</li>
<li>Examine existing applications</li>
<li>Consult domain experts</li>
<li>Realize domain model</li>
<li>Identify operations and relationships</li>
<li>Categorize components for implementation</li>
</ol>
<hr>
<h2 id="-12-14-2-component-based-development-2-"><strong>12.14.2 COMPONENT-BASED DEVELOPMENT</strong>[2]</h2>
<p><strong>Three Stages</strong>[2]</p>
<table>
<thead>
<tr>
<th>Stage</th>
<th>Activity</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Qualification</strong></td>
<td>Examine reusable components; assess performance, reliability, usability</td>
</tr>
<tr>
<td><strong>Adaptation (Wrapping)</strong></td>
<td>Modify components for compatibility</td>
</tr>
<tr>
<td><strong>Composition</strong></td>
<td>Integrate components into working system</td>
</tr>
</tbody>
</table>
<p><strong>Component Adaptation Approaches</strong>[2]</p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>White Box</strong></td>
<td>Directly modify component implementation (requires source code)</td>
</tr>
<tr>
<td><strong>Grey Box</strong></td>
<td>Use component library&#39;s extension language/API</td>
</tr>
<tr>
<td><strong>Black Box</strong></td>
<td>Pre/post-process at interface level (no source code)</td>
</tr>
</tbody>
</table>
<p><strong>Composition Infrastructure</strong>[2]
âœ“ Library of specialized components
âœ“ Coordination model for components
âœ“ Common task services
âœ“ Data Exchange Model (drag-drop, cut-paste)
âœ“ Underlying object model (interoperation across languages/platforms)</p>
<hr>
<h2 id="-12-15-component-technologies-2-"><strong>12.15 COMPONENT TECHNOLOGIES</strong>[2]</h2>
<p><strong>Available Technologies</strong>[2]</p>
<ul>
<li><strong>CORBA</strong> â€” remote communication, transparent over networks</li>
<li><strong>Java</strong> â€” cross-platform</li>
<li><strong>COM</strong> â€” Windows components</li>
<li><strong>COMCORBAbridging</strong> â€” integrate components across vendors/legacy systems</li>
</ul>
<hr>
<h2 id="-12-16-challenges-for-cbse-2-"><strong>12.16 CHALLENGES FOR CBSE</strong>[2]</h2>
<p><strong>Major Challenges</strong>[2]</p>
<table>
<thead>
<tr>
<th>Challenge</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Dependable Systems</strong></td>
<td>Limited quality assurance for safety-critical domains</td>
</tr>
<tr>
<td><strong>Tool Support</strong></td>
<td>Need component selection, evaluation, repository, test tools</td>
</tr>
<tr>
<td><strong>Trusted Components</strong></td>
<td>Binary delivery, external development; trustworthiness concerns</td>
</tr>
<tr>
<td><strong>Component Certification</strong></td>
<td>Standard procedure not yet established in software</td>
</tr>
<tr>
<td><strong>Composition Predictability</strong></td>
<td>Unknown how component attributes determine system attributes</td>
</tr>
<tr>
<td><strong>Requirements Management</strong></td>
<td>Incomplete, imprecise, contradictory requirements</td>
</tr>
<tr>
<td><strong>Component Selection</strong></td>
<td>Candidate components may lack required features</td>
</tr>
<tr>
<td><strong>System Evolution</strong></td>
<td>Components with independent lifecycles complicate maintenance</td>
</tr>
<tr>
<td><strong>Development Models</strong></td>
<td>Ambiguous, incomplete, difficult-to-use models</td>
</tr>
<tr>
<td><strong>Component Configuration</strong></td>
<td>Complex systems have many nested components</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-12-17-software-reengineering-2-"><strong>12.17 SOFTWARE REENGINEERING</strong>[2]</h2>
<p><strong>Definition</strong>[2]</p>
<ul>
<li>Examination, analysis, alteration of existing software system</li>
<li>Reconstitute in new form</li>
<li>Encompasses: reverse engineering, restructuring, redocumentation, forward engineering, retargeting</li>
</ul>
<p><strong>Reasons to Reengineer Legacy Systems</strong>[2]
âœ“ Allow quick adaptation to changing requirements
âœ“ Comply with new organizational standards
âœ“ Upgrade to newer technologies/platforms/paradigms
âœ“ Extend software life expectancy
âœ“ Identify reuse candidates
âœ“ Improve maintainability
âœ“ Increase maintenance programmer productivity
âœ“ Reduce reliance on specialized programmers
âœ“ Reduce maintenance errors and costs</p>
<hr>
<h2 id="-12-18-objectives-of-reengineering-2-"><strong>12.18 OBJECTIVES OF REENGINEERING</strong>[2]</h2>
<p><strong>Two General Objectives</strong>[2]</p>
<table>
<thead>
<tr>
<th>Objective</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Improve Quality</strong></td>
<td>Enhance reliability, maintainability, reduce maintenance cost; may apply OO technology</td>
</tr>
<tr>
<td><strong>Migration</strong></td>
<td>Transport to newer platforms/languages; may involve extensive redesign</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-12-19-software-reengineering-lifecycle-2-"><strong>12.19 SOFTWARE REENGINEERING LIFECYCLE</strong>[2]</h2>
<p><strong>Six Phases</strong>[2]</p>
<ol>
<li><p><strong>Requirements Analysis</strong></p>
<ul>
<li>Identify reengineering goals</li>
<li>Specify criteria for new system</li>
<li>Identify violations needing repair</li>
</ul>
</li>
<li><p><strong>Model Analysis</strong></p>
<ul>
<li>Document legacy system architecture</li>
<li>Capture design and functionality</li>
<li>Establish relationships between implementation elements</li>
<li>Preliminary model required for transformation</li>
</ul>
</li>
<li><p><strong>Source Code Analysis</strong></p>
<ul>
<li>Identify code responsible for requirement violations</li>
<li>Design methods and tools for inspection/measurement/ranking</li>
<li>Static analysis of code/design structure</li>
<li>Dynamic runtime behavior analysis</li>
</ul>
</li>
<li><p><strong>Remediation</strong></p>
<ul>
<li>Select target software structure</li>
<li>Repair design/source code defects</li>
<li>Decompose complex problems into sub-problems</li>
</ul>
</li>
<li><p><strong>Transformation</strong></p>
<ul>
<li>Physically transform software structures</li>
<li>Methods/tools for manipulation, reorganization, recompilation</li>
<li>Automated debugging and consistency checks</li>
<li>Version management</li>
</ul>
</li>
<li><p><strong>Evaluation</strong></p>
<ul>
<li>Assess new system</li>
<li>Establish and integrate revised system</li>
<li>Training and business process model adaptation</li>
</ul>
</li>
</ol>
<hr>
<h2 id="-12-20-reverse-engineering-vs-forward-engineering-2-"><strong>12.20 REVERSE ENGINEERING vs. FORWARD ENGINEERING</strong>[2]</h2>
<p><strong>Reverse Engineering</strong>[2]</p>
<ul>
<li>Process to improve understanding of program</li>
<li>Program comprehension crucial to maintenance</li>
<li>Often produces diagrams</li>
<li>Abstracts away irrelevant details</li>
<li><strong>Approximate time</strong>: 60% of reengineering effort</li>
</ul>
<p><strong>Forward Engineering</strong>[2]</p>
<ul>
<li>Engineering activities using legacy outputs</li>
<li>Produces new target system</li>
<li><strong>Approximate time</strong>: 40% of reengineering effort</li>
</ul>
<p><strong>Implementation Methods</strong>[2]</p>
<ul>
<li>Abstract Syntax Tree representation of source code</li>
<li>Annotations for linkage, scope, type information</li>
<li>Iterative transformation selection</li>
<li>Performance/maintainability enhancements</li>
</ul>
<hr>
<hr>
<h1 id="-unit-13-software-process-improvement-3-"><strong>UNIT 13: SOFTWARE PROCESS IMPROVEMENT</strong>[3]</h1>
<h2 id="-13-2-sei-cmmi-model-3-"><strong>13.2 SEI CMMI MODEL</strong>[3]</h2>
<p><strong>Overview</strong>[3]</p>
<ul>
<li><strong>Capability Maturity Model Integrated (CMMI)</strong> by Software Engineering Institute</li>
<li>Developed at Carnegie Mellon University</li>
<li>First version published in 1991</li>
<li><strong>Purpose</strong>: Resolve software process challenges, improve maturity levels</li>
<li>Covers technical, physical, functional aspects</li>
</ul>
<p><strong>Key Advantages</strong>[3]
âœ“ Improve processes using SEI-CMMi best practices
âœ“ Apply proven processes and methods
âœ“ Standardize and benchmark processes
âœ“ Assure deliverable quality
âœ“ Assess current maturity level
âœ“ Compare organizations using maturity levels
âœ“ Mitigate risks through proven methods</p>
<hr>
<h2 id="-13-2-sei-cmmi-levels-3-"><strong>13.2 SEI CMMI LEVELS</strong>[3]</h2>
<p><strong>Five Maturity Levels</strong>[3]</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Name</th>
<th>Focus</th>
<th>Key Areas</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>Initial</td>
<td>Ad-hoc development</td>
<td>No structured processes</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>Managed</td>
<td>Basic project management</td>
<td>Req. mgmt, planning, monitoring, quality</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>Defined</td>
<td>Process standardization</td>
<td>Requirements development, technical solution, integration</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>Quantitatively Managed</td>
<td>Quantitative management</td>
<td>Organizational process performance, project management</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>Continuous Improvement</td>
<td>Iterative improvement</td>
<td>Innovation and deployment, causal analysis</td>
</tr>
</tbody>
</table>
<p><strong>Level 1: Initial</strong>[3]</p>
<ul>
<li>Software developed ad hoc</li>
<li>No strategic approach</li>
<li>Success depends on team member skills</li>
<li>Cost and time not critical</li>
<li>Process unpredictable</li>
<li>Simple testing</li>
<li>Vast majority of orgs at this level</li>
</ul>
<p><strong>Level 2: Managed</strong>[3]</p>
<ul>
<li>Satisfies all Level 1 requirements</li>
<li>Basic project management policies and procedures</li>
<li>Learn from previous projects</li>
<li>Documented, implemented, trained processes</li>
<li>Quick problem-solving</li>
<li>Disciplined development</li>
<li>Realistic estimates without measurement</li>
</ul>
<p><strong>Level 3: Defined</strong>[3]</p>
<ul>
<li>Satisfies all Level 2 requirements</li>
<li>Well-defined, managed, documented processes</li>
<li>Staff training for knowledge</li>
<li>Standard practices tailored for projects</li>
</ul>
<p><strong>Level 4: Quantitatively Managed</strong>[3]</p>
<ul>
<li>Satisfies all Level 3 requirements</li>
<li>Quantitative standards for products/processes</li>
<li>Integrated organizational analysis</li>
<li>Collective database creation</li>
<li>Integrated performance measurement</li>
<li>Well-defined instruments</li>
<li>Predictable capability</li>
</ul>
<p><strong>Level 5: Optimizing</strong>[3]</p>
<ul>
<li>Satisfies all Level 4 requirements</li>
<li>Continuous process improvement</li>
<li>Quantitative feedback</li>
<li>Analyze weakness and take corrective steps</li>
<li>Change processes based on cost-benefit analysis</li>
<li>Almost perfect organization</li>
</ul>
<hr>
<h2 id="-13-3-first-time-right-ftr-framework-3-"><strong>13.3 FIRST TIME RIGHT (FTR) FRAMEWORK</strong>[3]</h2>
<p><strong>FTR Concept</strong>[3]</p>
<ul>
<li>Comprehensive framework incorporating best practices</li>
<li>Covers all SDLC phases</li>
<li>Addresses comprehensive program concerns</li>
<li><strong>Goal</strong>: Deliver correct solution on first attempt</li>
</ul>
<p><strong>Nine Optimization Categories</strong>[3]</p>
<ol>
<li>Requirements Related</li>
<li>Architecture and Design Related</li>
<li>Security Related</li>
<li>Testing Related</li>
<li>Development Related</li>
<li>DevOps Related</li>
<li>Infrastructure Related</li>
<li>Project Management Related</li>
<li>Governance Related</li>
</ol>
<hr>
<h2 id="-13-3-1-requirements-related-optimizations-3-"><strong>13.3.1 REQUIREMENTS RELATED OPTIMIZATIONS</strong>[3]</h2>
<p><strong>Key Optimizations</strong>[3]</p>
<table>
<thead>
<tr>
<th>Optimization</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Requirement Traceability Matrix</strong></td>
<td>Map use case/Jira story to test case, code, release; ensure no gaps</td>
</tr>
<tr>
<td><strong>Metrics and SLA Definition</strong></td>
<td>Quantify functional/non-functional requirements with accuracy</td>
</tr>
<tr>
<td><strong>NFR Definition and Sign-off</strong></td>
<td>Define security, performance, scalability, accessibility, multi-lingual</td>
</tr>
<tr>
<td><strong>Business Stakeholder Engagement</strong></td>
<td>Active involvement throughout requirement elaboration</td>
</tr>
<tr>
<td><strong>Prototype Demos</strong></td>
<td>Iterative mockups/prototypes for design, user journeys, multi-device</td>
</tr>
<tr>
<td><strong>Design Thinking Approach</strong></td>
<td>Empathize with user, explore alternatives, test solutions</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-13-3-2-architecture-and-design-optimizations-3-"><strong>13.3.2 ARCHITECTURE AND DESIGN OPTIMIZATIONS</strong>[3]</h2>
<p><strong>Key Optimizations</strong>[3]</p>
<table>
<thead>
<tr>
<th>Optimization</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Patterns-Based Design</strong></td>
<td>Identify application architecture patterns, industry best practices, design patterns</td>
</tr>
<tr>
<td><strong>Tools/Frameworks Evaluation</strong></td>
<td>Evaluate market-leading products, open source libraries for fitness</td>
</tr>
<tr>
<td><strong>Standards Definition</strong></td>
<td>Define applicable standards, architecture principles (headless, stateless, token-based)</td>
</tr>
<tr>
<td><strong>Optimal NFR and Integration</strong></td>
<td>Design for performance, scalability, availability SLAs</td>
</tr>
<tr>
<td><strong>Automation Tools</strong></td>
<td>Identify tools for code review, IDE, functional testing</td>
</tr>
<tr>
<td><strong>Feasibility Validation</strong></td>
<td>Conduct PoCs for complex requirements</td>
</tr>
<tr>
<td><strong>Architecture Trends</strong></td>
<td>Track and recommend tenets for architecture/technology/integration shifts</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-13-3-4-testing-related-optimizations-3-"><strong>13.3.4 TESTING RELATED OPTIMIZATIONS</strong>[3]</h2>
<p><strong>Key Optimizations</strong>[3]</p>
<table>
<thead>
<tr>
<th>Optimization</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Automated Testing</strong></td>
<td>Use tools (JMeter, Selenium) for regression and functional tests</td>
</tr>
<tr>
<td><strong>Continuous Iterative Testing</strong></td>
<td>Continuous testing across sprints for early defect discovery</td>
</tr>
<tr>
<td><strong>Testing Metrics Definition</strong></td>
<td>Define metrics: defect rate, slippage rate, defect density</td>
</tr>
<tr>
<td><strong>Dashboard Monitoring</strong></td>
<td>Pro-active quality metrics monitoring and critical violation notification</td>
</tr>
<tr>
<td><strong>Sprint-wise UAT</strong></td>
<td>Business stakeholder involvement per sprint for early gap discovery</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-13-3-5-development-related-optimizations-3-"><strong>13.3.5 DEVELOPMENT RELATED OPTIMIZATIONS</strong>[3]</h2>
<p><strong>Key Optimizations</strong>[3]</p>
<table>
<thead>
<tr>
<th>Optimization</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Code Checklist</strong></td>
<td>Language-specific practices, performance, security, naming conventions, design checklists</td>
</tr>
<tr>
<td><strong>Automated and Peer Review</strong></td>
<td>Use analyzers (PMD, SonarQube); frequent peer/lead reviews</td>
</tr>
<tr>
<td><strong>Code Reusability</strong></td>
<td>Leverage platform/org/approved open source libraries first</td>
</tr>
<tr>
<td><strong>Performance-Driven Dev</strong></td>
<td>Early performance testing; avoid memory leaks, bottlenecks</td>
</tr>
<tr>
<td><strong>Optimal Code Coverage</strong></td>
<td>Target &gt;90% code coverage with unit tests</td>
</tr>
<tr>
<td><strong>Quality Gating</strong></td>
<td>Multi-level gating: developer, automated analyzer, manual review, integrated review</td>
</tr>
<tr>
<td><strong>Automated Unit Testability</strong></td>
<td>Use automated generators (EvoSuite, Veracode)</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-13-3-6-devops-related-optimizations-3-"><strong>13.3.6 DEVOPS RELATED OPTIMIZATIONS</strong>[3]</h2>
<p><strong>Key Optimizations</strong>[3]</p>
<table>
<thead>
<tr>
<th>Optimization</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Release Management</strong></td>
<td>Automated release management system</td>
</tr>
<tr>
<td><strong>Automated Testing</strong></td>
<td>Configure unit/functional test jobs</td>
</tr>
<tr>
<td><strong>Automated Deployment</strong></td>
<td>Jenkins pipelines and deployment jobs</td>
</tr>
<tr>
<td><strong>Continuous Build</strong></td>
<td>Catch errors with integrated code</td>
</tr>
<tr>
<td><strong>Deployment Pipelines</strong></td>
<td>Automate code deployment</td>
</tr>
<tr>
<td><strong>Source Control</strong></td>
<td>Define pull request, approval, check-in, merge processes</td>
</tr>
<tr>
<td><strong>Automated Reporting</strong></td>
<td>Project health notifications and SLA violation triggers</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-13-3-7-infrastructure-optimizations-3-"><strong>13.3.7 INFRASTRUCTURE OPTIMIZATIONS</strong>[3]</h2>
<p><strong>Key Optimizations</strong>[3]</p>
<table>
<thead>
<tr>
<th>Optimization</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Health Check Monitoring</strong></td>
<td>Pro-active heartbeat monitoring</td>
</tr>
<tr>
<td><strong>Proper Capacity Sizing</strong></td>
<td>Size servers/network based on user load and NFRs</td>
</tr>
<tr>
<td><strong>Automated Alerts</strong></td>
<td>Configure notification triggers for SLA violations</td>
</tr>
<tr>
<td><strong>Monitoring Dashboard</strong></td>
<td>Key parameters: availability %, performance, utilization, request rate</td>
</tr>
<tr>
<td><strong>Availability Reports</strong></td>
<td>On-demand monitoring reports</td>
</tr>
<tr>
<td><strong>Real-time SLA Monitoring</strong></td>
<td>Multi-geography monitoring</td>
</tr>
<tr>
<td><strong>SPOF Avoidance</strong></td>
<td>Prevent single points of failure through cluster, redundancy, DR, backups</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-13-3-8-project-management-optimizations-3-"><strong>13.3.8 PROJECT MANAGEMENT OPTIMIZATIONS</strong>[3]</h2>
<p><strong>Key Optimizations</strong>[3]</p>
<table>
<thead>
<tr>
<th>Optimization</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Skill Training</strong></td>
<td>Train team members in required technology skills</td>
</tr>
<tr>
<td><strong>Proper Estimation</strong></td>
<td>Accurate effort estimates and resource staffing</td>
</tr>
<tr>
<td><strong>Reusable Knowledge Base</strong></td>
<td>Maintain SOPs, KDD, how-to docs, troubleshooting, learnings</td>
</tr>
<tr>
<td><strong>Open Communication</strong></td>
<td>Avoid information silos; leverage Slack, MS Teams</td>
</tr>
<tr>
<td><strong>KT Planning</strong></td>
<td>Plan knowledge transfer for new engagements</td>
</tr>
<tr>
<td><strong>Project Metrics Dashboard</strong></td>
<td>Track burn rate, code quality score, open defects, fix time, sprint rate</td>
</tr>
<tr>
<td><strong>Sprint-based Agile Delivery</strong></td>
<td>Plan for iterative delivery to mitigate risk</td>
</tr>
<tr>
<td><strong>Continuous Improvement</strong></td>
<td>Seek productivity/quality improvements; identify automation opportunities</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-13-3-9-governance-optimizations-3-"><strong>13.3.9 GOVERNANCE OPTIMIZATIONS</strong>[3]</h2>
<p><strong>Key Governance Types</strong>[3]</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Code Governance</strong></td>
<td>Code management processes: merging, check-in, versioning</td>
</tr>
<tr>
<td><strong>Change Request Governance</strong></td>
<td>Scope creep management; prioritization and impact management</td>
</tr>
<tr>
<td><strong>Defect Fix Governance</strong></td>
<td>Defect prioritization and SLAs</td>
</tr>
<tr>
<td><strong>Review Governance</strong></td>
<td>Code review and approval processes</td>
</tr>
<tr>
<td><strong>Feature Traceability</strong></td>
<td>Trace requirement to release</td>
</tr>
<tr>
<td><strong>Deployment Governance</strong></td>
<td>Deployment plan for code artifacts</td>
</tr>
<tr>
<td><strong>Rollout Governance</strong></td>
<td>Rollout plan across geographies, features, languages, rollback</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-13-4-performance-testing-and-validation-3-"><strong>13.4 PERFORMANCE TESTING AND VALIDATION</strong>[3]</h2>
<p><strong>Web Performance Test Methodology Phases</strong>[3]</p>
<ol>
<li><strong>Requirements Analysis</strong> â€” gather test needs, assess architecture, identify critical transactions</li>
<li><strong>Planning and Design</strong> â€” break scope into business transactions, characterize workload</li>
<li><strong>Environment Setup</strong> â€” finalize tools and setup performance environment</li>
<li><strong>Script Development</strong> â€” develop performance test scripts</li>
<li><strong>Execution</strong> â€” execute scripts, record metrics (load, stress, endurance testing)</li>
<li><strong>Reporting and Recommendation</strong> â€” analyze results, publish reports, go/no-go decision</li>
</ol>
<p><strong>Key Performance Questions</strong>[3]</p>
<ul>
<li>Which pages receive highest traffic?</li>
<li>How many pages have acceptable performance?</li>
<li>Which pages have bad performance?</li>
<li>What is the caching strategy?</li>
</ul>
<hr>
<h2 id="-13-5-process-examples-3-"><strong>13.5 PROCESS EXAMPLES</strong>[3]</h2>
<p><strong>13.5.1 Requirements Development (Level 3)</strong>[3]</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Focus Areas</strong></td>
<td>Understand requirements (business, operations, performance); integration requirements; exception scenarios</td>
</tr>
<tr>
<td><strong>Methods</strong></td>
<td>Comprehensive template; elaborate user stories; bi-directional traceability; stakeholder validation; prototype validation</td>
</tr>
</tbody>
</table>
<p><strong>13.5.2 Technical Solution (Level 3)</strong>[3]</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Focus Areas</strong></td>
<td>Alternate solution evaluation; scalable, high-performing solution design</td>
</tr>
<tr>
<td><strong>Methods</strong></td>
<td>Evaluate options against criteria; elaborate detailed design; static code analysis; unit tests; documentation</td>
</tr>
</tbody>
</table>
<p><strong>13.5.3 Requirements Management (Level 2)</strong>[3]</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Focus Areas</strong></td>
<td>Manage requirements; change management; identify inconsistencies</td>
</tr>
<tr>
<td><strong>Methods</strong></td>
<td>Various gathering methods (prototyping, interviews); change process definition; bi-directional traceability</td>
</tr>
</tbody>
</table>
<p><strong>13.5.4 Product Integration (Level 3)</strong>[3]</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Focus Areas</strong></td>
<td>All needed interfaces; optimal component assembly; integration SLAs</td>
</tr>
<tr>
<td><strong>Methods</strong></td>
<td>Integration specification; interface testing at various loads; exception scenario handling</td>
</tr>
</tbody>
</table>
<p><strong>13.5.5 Project Planning (Level 2)</strong>[3]</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Focus Areas</strong></td>
<td>Accurate scope/effort/time estimation; risk management; stakeholder management</td>
</tr>
<tr>
<td><strong>Methods</strong></td>
<td>Accurate estimates; comprehensive plan (risks, milestones, metrics, dependencies); stakeholder identification; engagement plan</td>
</tr>
</tbody>
</table>
<hr>
<p>Perfect! Now I have all three units. Let me create comprehensive summaries in the same detailed pattern.</p>
<h1 id="-comprehensive-summary-units-14-15-and-16-"><strong>COMPREHENSIVE SUMMARY: UNITS 14, 15, AND 16</strong></h1>
<hr>
<h1 id="-unit-14-emerging-trends-in-software-engineering-1-"><strong>UNIT 14: EMERGING TRENDS IN SOFTWARE ENGINEERING</strong>[1]</h1>
<h2 id="-14-0-introduction-1-"><strong>14.0 INTRODUCTION</strong>[1]</h2>
<p><strong>Context</strong>[1]</p>
<ul>
<li>Software engineering is rapidly evolving with fast-paced changes and innovations</li>
<li>Driven by market demands, user demands, productivity improvement, quality improvement, cost optimization, high performance, high availability, and high scalability</li>
<li>Software engineers must track industry changes and stay updated</li>
</ul>
<hr>
<h2 id="-14-2-drivers-for-innovation-1-"><strong>14.2 DRIVERS FOR INNOVATION</strong>[1]</h2>
<p><strong>Key Drivers</strong>[1]</p>
<table>
<thead>
<tr>
<th>Driver</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Productivity Improvement</strong></td>
<td>Methods (low-code/no-code, containerization) and delivery models reduce time to market</td>
</tr>
<tr>
<td><strong>Quality Improvement</strong></td>
<td>Process innovations (continuous improvement, agile delivery) enhance quality and reduce risk</td>
</tr>
<tr>
<td><strong>User Experience &amp; Engagement</strong></td>
<td>Innovations (AR, VR, AI, blockchain, ML) improve end-user experience and contextual information</td>
</tr>
<tr>
<td><strong>Automation</strong></td>
<td>AI and Machine Learning enable driving automation</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-14-3-key-emerging-trends-1-"><strong>14.3 KEY EMERGING TRENDS</strong>[1]</h2>
<p><strong>Main Trends Overview</strong>[1]
âœ“ <strong>Low Code/No Code</strong> â€” minimal code development with visual tools
âœ“ <strong>Artificial Intelligence (AI)</strong> â€” analyze data, detect patterns, predict trends
âœ“ <strong>Blockchain</strong> â€” secured distributed record handling
âœ“ <strong>Internet of Things (IoT)</strong> â€” track and monitor devices
âœ“ <strong>Continuous Delivery</strong> â€” iterative and agile delivery with incremental features
âœ“ <strong>Cloud Platforms</strong> â€” redefined software building, deployment, delivery
âœ“ <strong>Containerization</strong> â€” self-contained and portable deployment
âœ“ <strong>Big Data</strong> â€” massive volume with high performance and availability
âœ“ <strong>Augmented Reality (AR)</strong> â€” enhance real-world objects with digital content
âœ“ <strong>Mobile-First, Cloud-First, Offline-First</strong> â€” emerging delivery methods</p>
<p><strong>Other Emerging Trends</strong>[1]</p>
<ul>
<li>Serverless functions</li>
<li>Conversational applications</li>
<li>Analytics</li>
<li>Computer vision</li>
<li>Service orchestration</li>
<li>Software as Service (SaaS)</li>
<li>Cross-platform development</li>
</ul>
<hr>
<h2 id="-14-4-1-low-code-and-no-code-platforms-1-"><strong>14.4.1 LOW CODE AND NO CODE PLATFORMS</strong>[1]</h2>
<p><strong>Definition and Purpose</strong>[1]</p>
<ul>
<li>Allow users to rapidly build UIs, solution components, integrations with zero or minimal code</li>
<li>Designed to fill gap between enterprise demand for rapid application development and shortage of skilled developers</li>
<li>New avatar of Rapid Application Development (RAD) tools</li>
</ul>
<p><strong>Key Features</strong>[1]
âœ“ Visual programming model for citizen developers
âœ“ Pre-built integrators for faster data retrieval and persistence
âœ“ Drag-and-drop features for rapid application building
âœ“ Model-driven approach for building solutions
âœ“ Reusable pre-built components and solution accelerators
âœ“ Configurable solution components for business needs</p>
<p><strong>Salient Characteristics</strong>[1]</p>
<ul>
<li>Automate code generation through abstraction</li>
<li>Use visual programming paradigm</li>
<li>Leverage model-based design</li>
<li>Reduce hand coding effort</li>
</ul>
<p><strong>Key Advantages</strong>[1]
âœ“ Faster time to market
âœ“ Improved developer productivity
âœ“ Enable business teams with minimal coding experience
âœ“ Rapid development and deployment
âœ“ Increased solution quality
âœ“ Scalable applications with reusable components
âœ“ Quicker integration with enterprise systems
âœ“ Enable business self-service model
âœ“ Make enterprises more agile and responsive to market dynamics
âœ“ Enable faster innovation with increased productivity</p>
<p><strong>Popular LCNC Platforms</strong>[1]</p>
<ul>
<li><strong>Pega software</strong> â€” visual tools for enterprise business process modeling and screen building</li>
<li><strong>Salesforce Lightning</strong> â€” automation tools for process builder, mobile app development with minimal code</li>
<li><strong>Microsoft Power Platform</strong> â€” pre-defined templates, easy connections, cross-platform apps</li>
<li><strong>Appian</strong> â€” drag-and-drop features for complex business process modeling</li>
</ul>
<hr>
<h2 id="-14-4-2-artificial-intelligence-ai-1-"><strong>14.4.2 ARTIFICIAL INTELLIGENCE (AI)</strong>[1]</h2>
<p><strong>Definition</strong>[1]</p>
<ul>
<li>Guiding force behind automation revolution</li>
<li>Helps machines &quot;learn&quot; and &quot;understand&quot; like humans</li>
<li>Interdisciplinary science using NLP, machine learning, knowledge processing, reasoning, predicting</li>
</ul>
<p><strong>Purpose</strong>[1]</p>
<ul>
<li>Make machines perform intelligent and cognitive tasks humans excel at</li>
<li>Tasks: game playing, language translation, pattern recognition, image identification, decision-making, problem-solving, reasoning</li>
</ul>
<p><strong>Disciplines Contributing to AI</strong>[1]</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Contribution</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Philosophy</strong></td>
<td>Logical reasoning, theory of rationality, language theory, reasoning</td>
</tr>
<tr>
<td><strong>Mathematics</strong></td>
<td>Probability, logic, algorithms, decidability, formal representation</td>
</tr>
<tr>
<td><strong>Economics</strong></td>
<td>Game theory, formal theory of rational decisions, Markov decision processes</td>
</tr>
<tr>
<td><strong>Linguistics</strong></td>
<td>Grammar, NLP, knowledge representation, language understanding</td>
</tr>
<tr>
<td><strong>Statistics</strong></td>
<td>Regression models, learning from data, modeling uncertainty</td>
</tr>
<tr>
<td><strong>Neuroscience</strong></td>
<td>Neurons as information units, artificial neural networks, brain functioning</td>
</tr>
<tr>
<td><strong>Psychology</strong></td>
<td>Behaviorism, cognitive psychology, perception, motor control, human learning</td>
</tr>
<tr>
<td><strong>Computer Science</strong></td>
<td>Programming, algorithms, design patterns, parallel computing, data structures</td>
</tr>
<tr>
<td><strong>Control Theory</strong></td>
<td>System stability, optimal agent design, feedback systems</td>
</tr>
</tbody>
</table>
<p><strong>Key AI Applications</strong>[1]</p>
<table>
<thead>
<tr>
<th>Application</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Autonomous Vehicles</strong></td>
<td>Obstacle sensing, automatic navigation, autonomous planning, sensor data processing</td>
</tr>
<tr>
<td><strong>Conversational Interface</strong></td>
<td>Chatbots, virtual assistants (Siri, Alexa) for natural language interaction</td>
</tr>
<tr>
<td><strong>Computer Vision</strong></td>
<td>Machines perceive images through computer vision methods</td>
</tr>
<tr>
<td><strong>Robotics</strong></td>
<td>Commercial/industrial robots for well-defined tasks, complex surgeries</td>
</tr>
<tr>
<td><strong>Natural Language Processing</strong></td>
<td>Entity extraction, POS identification, intent identification, language understanding</td>
</tr>
<tr>
<td><strong>Expert Systems</strong></td>
<td>Specialized activities (legal advisory, medical advisory, domain-specific diagnosis)</td>
</tr>
<tr>
<td><strong>Game Playing</strong></td>
<td>Automated reasoning, decision-making for Chess, Go, Checkers, Jeopardy!</td>
</tr>
<tr>
<td><strong>Theorem Proving</strong></td>
<td>Prove correctness of mathematical theorems</td>
</tr>
<tr>
<td><strong>Vision/Perception</strong></td>
<td>Object recognition, face recognition, navigation, information extraction</td>
</tr>
<tr>
<td><strong>Search &amp; QA Systems</strong></td>
<td>Search engines and question answering</td>
</tr>
</tbody>
</table>
<p><strong>Emerging AI Trends</strong>[1]
âœ“ <strong>Deep Learning</strong> â€” artificial neural networks for complex tasks
âœ“ <strong>Autonomous Vehicles</strong> â€” consumer and transportation vehicles
âœ“ <strong>Facial Recognition</strong> â€” biometric authentication gaining popularity
âœ“ <strong>Edge AI</strong> â€” AI chips for faster execution of facial recognition, NLP, speech recognition
âœ“ <strong>Conversational AI</strong> â€” chatbots for incident management, text/voice search
âœ“ <strong>Analytics</strong> â€” AI with analytics for accurate predictive analytics
âœ“ <strong>Personalized Search</strong> â€” algorithms learn user interests and behavior
âœ“ <strong>Explainable AI</strong> â€” algorithms explain results and reasoning for governance
âœ“ <strong>Cognitive Computing</strong> â€” emerging technologies for contextual, interactive information
âœ“ <strong>Reinforcement Learning</strong> â€” learn through experience without explicit rules
âœ“ <strong>Convergence</strong> â€” with IoT, Blockchain, and other emerging technologies</p>
<hr>
<h2 id="-14-4-3-blockchain-1-"><strong>14.4.3 BLOCKCHAIN</strong>[1]</h2>
<p><strong>Definition</strong>[1]</p>
<ul>
<li>Decentralized, distributed database with non-tamperable record keeping</li>
<li>Built using peer-to-peer systems with cryptographic security</li>
<li>Used as ledger for transactions providing immutable and publicly viewable records</li>
</ul>
<p><strong>Key Features</strong>[1]
âœ“ Permanent and distributed record of all genuine transactions
âœ“ Decentralized governance
âœ“ <strong>Immutable and Irreversible</strong> data due to chained and distributed nature
âœ“ Transparent way to track records and transactions
âœ“ Secure transaction performance
âœ“ Data updates only upon consensus among participants</p>
<p><strong>Key Applications</strong>[1]
âœ“ Store legal contracts that cannot be tampered
âœ“ Company&#39;s product inventory information
âœ“ Supply chain information tracking throughout product lifecycle
âœ“ Cryptocurrency management
âœ“ Secure medical records storage
âœ“ Property records storage and management</p>
<hr>
<h2 id="-14-4-4-internet-of-things-iot-1-"><strong>14.4.4 INTERNET OF THINGS (IoT)</strong>[1]</h2>
<p><strong>Definition</strong>[1]</p>
<ul>
<li>Network of objects (&quot;things&quot;) with embedded sensors, software, devices</li>
<li>Objects track, monitor, collect, and exchange data</li>
<li>Enabled by 5G technology for interconnected devices</li>
</ul>
<p><strong>Key Components</strong>[1]</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Sensors</strong></td>
<td>Collect information about objects (light, temperature, etc.)</td>
</tr>
<tr>
<td><strong>Communication</strong></td>
<td>Sensors communicate collected information to cloud platform</td>
</tr>
<tr>
<td><strong>Data Analysis</strong></td>
<td>Analyze incoming data stream for trends, patterns, insights; use ML and big data methods</td>
</tr>
</tbody>
</table>
<p><strong>Key Advantages</strong>[1]
âœ“ <strong>Increased User Experience</strong> â€” real-time tracking provides accurate predictions
âœ“ <strong>Cost Optimization</strong> â€” preventive maintenance reduces machine downtime
âœ“ <strong>Remote Monitoring and Control</strong> â€” monitor and control devices remotely in real time
âœ“ <strong>Advanced Analytics</strong> â€” pro-active cost reduction insights</p>
<hr>
<h2 id="-14-4-5-augmented-reality-extended-reality-ar-1-"><strong>14.4.5 AUGMENTED REALITY/EXTENDED REALITY (AR)</strong>[1]</h2>
<p><strong>Definition</strong>[1]</p>
<ul>
<li>Enhances natural world objects by overlaying computer-generated information</li>
<li>Uses multiple technologies: AI, computer vision, analytics</li>
<li>Makes physical world objects more interactive through image, video, text, sound overlay</li>
</ul>
<p><strong>Example Applications</strong>[1]</p>
<ul>
<li>Mobile apps showing virtual clothing fitting</li>
<li>Virtual house painting with various colors</li>
<li>Pokemon GO â€” overlaying characters onto real world</li>
</ul>
<p><strong>Key AR Modules</strong>[1]
âœ“ OpenCV
âœ“ Google Lens
âœ“ ARCore
âœ“ Google ML toolkit</p>
<p><strong>AR Architecture Components</strong>[1]</p>
<ul>
<li>Environmental/mask information from Computer Vision</li>
<li>Semantic interpretation by AR Module</li>
<li>Data cleaning and refinement in preprocessing</li>
<li>ML Model Training for initial trained models</li>
<li>Additional layers/Suppression layers for mobile device efficiency</li>
<li>Real-time visualization on edge</li>
</ul>
<hr>
<h2 id="-14-4-6-containerization-1-"><strong>14.4.6 CONTAINERIZATION</strong>[1]</h2>
<p><strong>Definition</strong>[1]</p>
<ul>
<li>Virtualized environments providing independent, portable computing environments</li>
<li>Implement &quot;write once, run anywhere&quot; concept</li>
<li>Contain all software: libraries, tools, programming languages, runtimes, dependencies, configurations</li>
<li>Docker is most popular container technology</li>
</ul>
<p><strong>Key Features</strong>[1]</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Portability</strong></td>
<td>Easily port containers across environments regardless of OS or infrastructure</td>
</tr>
<tr>
<td><strong>Independence</strong></td>
<td>Self-contained and independent platforms</td>
</tr>
<tr>
<td><strong>Management</strong></td>
<td>Easy management of computing resources (CPU, memory, DNS, load balancing)</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>Easy management of sensitive/confidential information</td>
</tr>
</tbody>
</table>
<p><strong>Key Advantages</strong>[1]
âœ“ <strong>Performance</strong> â€” lightweight virtualization with better performance than traditional VMs
âœ“ <strong>DevOps Friendly</strong> â€” fits modern DevOps methodology
âœ“ <strong>Flexibility and Scalability</strong> â€” Kubernetes provides elastic scalability with auto-scaling
âœ“ <strong>Fault Isolation</strong> â€” failures don&#39;t impact other containers
âœ“ <strong>Agility and Speed</strong> â€” easily configure and spin up containers on demand
âœ“ <strong>Efficiency</strong> â€” lightweight, scalable, easy management, faster updates
âœ“ <strong>Logging and Monitoring</strong> â€” comprehensive logging and monitoring support</p>
<hr>
<h2 id="-14-4-7-continuous-delivery-1-"><strong>14.4.7 CONTINUOUS DELIVERY</strong>[1]</h2>
<p><strong>Definition</strong>[1]</p>
<ul>
<li>Set of processes, tools, technologies for iterative and agile delivery</li>
<li>Provides solution delivery with incremental features</li>
<li><strong>Key Concept</strong>: frequently release new features to production</li>
</ul>
<p><strong>Components</strong>[1]
âœ“ Automated testing
âœ“ Automated deployment
âœ“ Continuous build
âœ“ Deployment pipelines
âœ“ Source control management
âœ“ Release management
âœ“ Automated reporting and health notifications</p>
<hr>
<h2 id="-14-4-8-cloud-platforms-1-"><strong>14.4.8 CLOUD PLATFORMS</strong>[1]</h2>
<p><strong>Impact</strong>[1]</p>
<ul>
<li>Redefined the way software is built, deployed, and delivered</li>
<li>Provides scalable computing resources on demand</li>
</ul>
<p><strong>Delivery Models</strong>[1]</p>
<table>
<thead>
<tr>
<th>Model</th>
<th>Type</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IaaS</strong></td>
<td>Infrastructure as Service</td>
<td>Virtual machines, servers, computing resources</td>
</tr>
<tr>
<td><strong>PaaS</strong></td>
<td>Platform as Service</td>
<td>Development platforms, middleware, runtime environments</td>
</tr>
<tr>
<td><strong>SaaS</strong></td>
<td>Software as Service</td>
<td>Ready-to-use software applications</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-14-4-9-big-data-1-"><strong>14.4.9 BIG DATA</strong>[1]</h2>
<p><strong>Definition</strong>[1]</p>
<ul>
<li>Technologies designed to handle massive volumes of data</li>
<li>Provide high performance and high availability</li>
</ul>
<p><strong>Characteristics</strong>[1]</p>
<ul>
<li><strong>Volume</strong> â€” massive amount of data</li>
<li><strong>Velocity</strong> â€” rate of data generation</li>
<li><strong>Veracity</strong> â€” accuracy and trustworthiness</li>
<li><strong>Variety</strong> â€” structured, semi-structured, unstructured data</li>
</ul>
<hr>
<h2 id="-14-4-10-software-development-methodologies-1-"><strong>14.4.10 SOFTWARE DEVELOPMENT METHODOLOGIES</strong>[1]</h2>
<p><strong>Agile Methodology</strong>[1]</p>
<ul>
<li><strong>Key Practice</strong>: Sprint-based delivery (typically 2-week cycles)</li>
<li>Continuous feedback and iterative improvement</li>
<li>Mitigates risk through incremental delivery</li>
<li>Early user feedback integration</li>
</ul>
<hr>
<h2 id="-14-4-11-other-emerging-trends-1-"><strong>14.4.11 OTHER EMERGING TRENDS</strong>[1]</h2>
<p><strong>Serverless Computing</strong>[1]</p>
<ul>
<li>Developers quickly develop and deploy business functions without bothering about servers</li>
<li>Examples: AWS Lambda, Azure Functions</li>
</ul>
<p><strong>Cross-Platform Development</strong>[1]</p>
<ul>
<li>Develop code once and reuse for multiple mobile platforms</li>
<li>Platforms: Android, iOS, Windows, Linux</li>
<li>Examples: Xamarin, Google Flutter</li>
</ul>
<p><strong>Conversational Interfaces</strong>[1]</p>
<ul>
<li>AI-powered chatbots understand and respond to natural language queries</li>
<li>Customizable for functional domain-specific data</li>
<li>Handling first-level queries in banking, retail, e-commerce</li>
</ul>
<p><strong>Offline-First Approach</strong>[1]</p>
<ul>
<li>Applications built for handling network unavailability</li>
<li>Use local storage mechanisms</li>
<li>Progressive Web Applications (PWA) provide offline capabilities</li>
</ul>
<hr>
<hr>
<h1 id="-unit-15-introduction-to-uml-2-"><strong>UNIT 15: INTRODUCTION TO UML</strong>[2]</h1>
<h2 id="-15-0-introduction-2-"><strong>15.0 INTRODUCTION</strong>[2]</h2>
<p><strong>Definition</strong>[2]</p>
<ul>
<li><strong>UML</strong> = Unified Modeling Language</li>
<li>Standards-based, general purpose modeling language</li>
<li>Language independent (works with Java, Python, C#, etc.)</li>
<li>Provides software blueprint in visual representation</li>
</ul>
<hr>
<h2 id="-15-2-background-of-object-oriented-design-2-"><strong>15.2 BACKGROUND OF OBJECT-ORIENTED DESIGN</strong>[2]</h2>
<p><strong>Function-Oriented Programming</strong>[2]</p>
<ul>
<li>Emphasizes algorithms</li>
<li>Function/procedure is basic building block</li>
<li>Top-down approach</li>
<li>Suits smaller, less complex systems</li>
<li>High complexity due to inherent coupling and behavioral relationships</li>
</ul>
<p><strong>Object-Oriented Programming</strong>[2]</p>
<ul>
<li>Data exposed only through interfaces</li>
<li>Bottom-up approach</li>
<li>Objects represent logical units or real-world entities</li>
<li><strong>Advantages</strong>:
âœ“ Designed for change
âœ“ Allows reuse
âœ“ Improves productivity
âœ“ Speeds up development time
âœ“ Improves maintainability
âœ“ Builds scalable and modular applications</li>
<li>Well-suited for inherently complex problems</li>
</ul>
<hr>
<h2 id="-15-3-key-concepts-of-object-oriented-design-2-"><strong>15.3 KEY CONCEPTS OF OBJECT-ORIENTED DESIGN</strong>[2]</h2>
<p><strong>Core Concepts</strong>[2]</p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Objects</strong></td>
<td>Basic building blocks; instances of classes representing real-world entities</td>
</tr>
<tr>
<td><strong>Classes</strong></td>
<td>Blueprints of objects; encapsulate data and behavior</td>
</tr>
<tr>
<td><strong>Encapsulation</strong></td>
<td>Data exposed only through functions; avoids tight coupling; also called data hiding/information hiding</td>
</tr>
<tr>
<td><strong>Abstraction</strong></td>
<td>Hides inner details and exposes behavior through interface; defines clear boundaries</td>
</tr>
<tr>
<td><strong>Modularity</strong></td>
<td>Partitions components based on responsibilities; loosely coupled, cohesive modules</td>
</tr>
<tr>
<td><strong>Inheritance</strong></td>
<td>Child class obtains characteristics and behavior of parent class; models hierarchy</td>
</tr>
<tr>
<td><strong>Composition</strong></td>
<td>One object is composed of other objects</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-15-4-introduction-to-uml-diagrams-2-"><strong>15.4 INTRODUCTION TO UML DIAGRAMS</strong>[2]</h2>
<p><strong>Background</strong>[2]</p>
<ul>
<li>Released in 1997 as common design language</li>
<li>Language independent models</li>
<li>Visual modeling from multiple perspectives</li>
</ul>
<p><strong>Definition</strong>[2]
&quot;A Unified Modeling Language is a structured language that provides the commonly agreed vocabulary to communicate, model and document the structural and behavioral aspects of the software system.&quot;</p>
<p><strong>Key Advantages</strong>[2]
âœ“ Models big picture of entire application
âœ“ Provides common language and vocabulary for understanding and discussing design
âœ“ Helps understand system conformance to business and technical requirements
âœ“ Developers get clear understanding of classes, components, interfaces, relationships
âœ“ Enables faster low-level design and implementation
âœ“ Helps analyze impact areas during enhancements or bug fixes
âœ“ Implements architecture best practices (loose coupling, layered architecture)
âœ“ Makes system easy to develop, maintain, and change
âœ“ Documents system from various perspectives and architecture decisions
âœ“ Visualizes overall structure and behavior of system and components</p>
<p><strong>Classification of UML Diagrams</strong>[2]</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Category</th>
<th>Elements</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Structural/Static</strong></td>
<td>Structure Diagrams</td>
<td>Class, Object, Component, Deployment, Package diagrams</td>
</tr>
<tr>
<td><strong>Behavioral/Dynamic</strong></td>
<td>Behavior Diagrams</td>
<td>Sequence, Collaboration, State, Activity, Use case diagrams</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-15-4-views-covered-by-uml-diagrams-2-"><strong>15.4 VIEWS COVERED BY UML DIAGRAMS</strong>[2]</h2>
<p><strong>Four Key Views</strong>[2]</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Focus</th>
<th>Diagrams</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Design View</strong></td>
<td>System functionality</td>
<td>Class diagram (static), Activity diagram, State chart diagram (dynamic)</td>
</tr>
<tr>
<td><strong>Implementation View</strong></td>
<td>Implementation components and interactions</td>
<td>Components (static), Interactions (dynamic)</td>
</tr>
<tr>
<td><strong>Process View</strong></td>
<td>Sequence of steps, flow, components in use case</td>
<td>Use case diagram, Throughput, Scalability</td>
</tr>
<tr>
<td><strong>Deployment View</strong></td>
<td>Physical architecture and distribution</td>
<td>Hardware (servers, load balancers, firewalls), Software artifacts, Capacity sizing</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-15-4-extensibility-of-uml-diagrams-2-"><strong>15.4 EXTENSIBILITY OF UML DIAGRAMS</strong>[2]</h2>
<p><strong>Extension Features</strong>[2]</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Stereotypes</strong></td>
<td>Extend UML vocabulary with application-specific elements</td>
</tr>
<tr>
<td><strong>Constraints</strong></td>
<td>Add business rules and conditions</td>
</tr>
<tr>
<td><strong>Tagging</strong></td>
<td>Specify additional metadata for objects</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-15-5-structural-uml-diagrams-2-"><strong>15.5 STRUCTURAL UML DIAGRAMS</strong>[2]</h2>
<p><strong>Key Structural Elements</strong>[2]</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Class</strong></td>
<td>Logical unit encapsulating state (attributes) and behavior (operations); can interact with other classes</td>
</tr>
<tr>
<td><strong>Interface</strong></td>
<td>Specifies contract for implementation through operations</td>
</tr>
<tr>
<td><strong>Object</strong></td>
<td>Instance of class; interacts by passing messages</td>
</tr>
<tr>
<td><strong>Component</strong></td>
<td>Logical module exposing interfaces for interaction</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Represents specific functionality and its implementation flow</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-15-5-1-class-diagram-2-"><strong>15.5.1 CLASS DIAGRAM</strong>[2]</h2>
<p><strong>Purpose</strong>[2]</p>
<ul>
<li>Visually provides object-oriented design of system</li>
<li>Depicts relationships between implementation classes</li>
<li>Shows inheritance, composition, association relationships</li>
</ul>
<p><strong>Class Diagram Components</strong>[2]
âœ“ Class name
âœ“ Attributes
âœ“ Visibility (public, protected, private)
âœ“ Associations
âœ“ Operations
âœ“ Comments (optional)</p>
<p><strong>Relationship Types</strong>[2]</p>
<table>
<thead>
<tr>
<th>Relationship</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Association</strong></td>
<td>Set of related links among objects; single object associated with multiple others</td>
</tr>
<tr>
<td><strong>Composition</strong></td>
<td>Strong form of association; dependent objects cannot exist independently</td>
</tr>
<tr>
<td><strong>Aggregation</strong></td>
<td>Weak form of association; independent objects can exist without parent</td>
</tr>
<tr>
<td><strong>Dependency</strong></td>
<td>One element depends on another; changes in independent element affect dependent</td>
</tr>
<tr>
<td><strong>Generalization</strong></td>
<td>Inheritance (parent-child relationship); child inherits from parent</td>
</tr>
<tr>
<td><strong>Realization</strong></td>
<td>Contract between entities; typically interface-to-implementation class</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-15-5-2-object-diagram-2-"><strong>15.5.2 OBJECT DIAGRAM</strong>[2]</h2>
<p><strong>Purpose</strong>[2]</p>
<ul>
<li>Depicts instantiated objects and their state</li>
<li>Represents relationships between objects</li>
</ul>
<hr>
<h2 id="-15-5-3-component-diagram-2-"><strong>15.5.3 COMPONENT DIAGRAM</strong>[2]</h2>
<p><strong>Definition</strong>[2]</p>
<ul>
<li>Represents logically related entities (classes and dependents)</li>
<li>Interact with other components through well-defined interfaces</li>
</ul>
<p><strong>Purpose</strong>[2]</p>
<ul>
<li>Provides physical view of application</li>
<li>Models software components and their dependencies</li>
<li>Depicts organization of physical entities</li>
</ul>
<p><strong>Key Focus</strong>[2]</p>
<ul>
<li>High-order solution components or packages</li>
<li>Interfaces exposed by components</li>
<li>Interactions with other components</li>
</ul>
<hr>
<h2 id="-15-5-4-deployment-diagram-2-"><strong>15.5.4 DEPLOYMENT DIAGRAM</strong>[2]</h2>
<p><strong>Purpose</strong>[2]</p>
<ul>
<li>Depicts details of solution components deployed on infrastructure</li>
<li>Shows hardware and software relationships</li>
</ul>
<p><strong>Components Shown</strong>[2]
âœ“ <strong>Hardware</strong>: servers, load balancers, firewalls, virtual machines, routers, storage
âœ“ <strong>Software Artifacts</strong>: files, Java Archives, libraries, executables
âœ“ <strong>Nodes</strong>: infrastructure elements and dependencies</p>
<p><strong>Audience Benefits</strong>[2]</p>
<ul>
<li>Systems support teams understand physical components needed</li>
<li>Infrastructure teams size system and do capacity planning</li>
<li>Overall system topology, software used, distribution model visible</li>
</ul>
<hr>
<h2 id="-15-5-5-package-diagram-2-"><strong>15.5.5 PACKAGE DIAGRAM</strong>[2]</h2>
<p><strong>Purpose</strong>[2]</p>
<ul>
<li>Depicts packages and constituent elements</li>
<li>Organizes classes into logical groups</li>
<li>Depicts relationships between packages</li>
</ul>
<p><strong>Benefits</strong>[2]
âœ“ Enhance readability
âœ“ Logically group and organize classes
âœ“ Decompose system into subsystems and subsystems into packages
âœ“ Better overall system organization</p>
<hr>
<h2 id="-15-6-behavioral-uml-diagrams-2-"><strong>15.6 BEHAVIORAL UML DIAGRAMS</strong>[2]</h2>
<p><strong>Key Behavioral Elements</strong>[2]</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Interaction</strong></td>
<td>Message passing between elements; represented as arrow</td>
</tr>
<tr>
<td><strong>State Machine</strong></td>
<td>Various states of object upon receiving event</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-15-6-1-state-chart-diagram-2-"><strong>15.6.1 STATE CHART DIAGRAM</strong>[2]</h2>
<p><strong>Purpose</strong>[2]</p>
<ul>
<li>Depicts event-driven state change behavior</li>
<li>Shows transitions from one state to another for specific events</li>
<li>Describes system behavior for external and internal events</li>
</ul>
<p><strong>Key Elements</strong>[2]
âœ“ Starting state (initial state) â€” starting point
âœ“ States â€” various object states
âœ“ Transition lines â€” connecting states
âœ“ Decision points</p>
<p><strong>Benefits</strong>[2]</p>
<ul>
<li>Understand system response to internal and external events</li>
</ul>
<hr>
<h2 id="-15-6-2-activity-diagram-2-"><strong>15.6.2 ACTIVITY DIAGRAM</strong>[2]</h2>
<p><strong>Purpose</strong>[2]</p>
<ul>
<li>Depicts control flow from one activity to another</li>
<li>Models system workflows, business rules, business processes</li>
<li>Represents parallel and sequential activities</li>
<li>Models use case execution steps</li>
</ul>
<p><strong>Characteristics</strong>[2]</p>
<ul>
<li>Type of state chart diagram where states are activities</li>
<li>Business-friendly notation</li>
<li>Initial and termination states with transition lines</li>
<li>Conditions represented</li>
</ul>
<p><strong>Benefits</strong>[2]</p>
<ul>
<li>Understand business logic and workflows</li>
</ul>
<hr>
<h2 id="-15-6-3-sequence-diagram-2-"><strong>15.6.3 SEQUENCE DIAGRAM</strong>[2]</h2>
<p><strong>Purpose</strong>[2]</p>
<ul>
<li>Depicts flow for specific use case or scenario</li>
<li>Shows objects performing calls by passing messages</li>
<li>Time-ordered sequence of messages</li>
</ul>
<p><strong>Components</strong>[2]
âœ“ Arrows â€” represent messages
âœ“ Narrow vertical rectangles â€” depict activations
âœ“ Classes â€” in top columns</p>
<p><strong>Benefits</strong>[2]</p>
<ul>
<li>Understand objects and order of invocation for specific use case</li>
</ul>
<hr>
<h2 id="-15-6-4-use-case-diagram-2-"><strong>15.6.4 USE CASE DIAGRAM</strong>[2]</h2>
<p><strong>Purpose</strong>[2]</p>
<ul>
<li>Depicts functional behavior of system in visual format</li>
<li>Usually represents single logical use case</li>
<li>Visual depiction of relationships between actors, use cases, components</li>
</ul>
<p><strong>Depicts</strong>[2]
âœ“ Interactions with external interfaces
âœ“ Relationship with actors
âœ“ Specific functionality from user&#39;s point of view</p>
<hr>
<h2 id="-15-6-5-collaboration-diagram-2-"><strong>15.6.5 COLLABORATION DIAGRAM</strong>[2]</h2>
<p><strong>Definition</strong>[2]</p>
<ul>
<li>Consists of objects and links representing systems</li>
<li>Shows messages sent across systems</li>
<li>Similar to sequence diagram</li>
</ul>
<hr>
<hr>
<h1 id="-unit-16-data-science-for-software-engineers-3-"><strong>UNIT 16: DATA SCIENCE FOR SOFTWARE ENGINEERS</strong>[3]</h1>
<h2 id="-16-0-introduction-3-"><strong>16.0 INTRODUCTION</strong>[3]</h2>
<p><strong>Context</strong>[3]</p>
<ul>
<li>Living in data-driven world where making sense of raw data is information super power</li>
<li>Data growing exponentially from tweets, posts, images, videos, IoT sensors, wearables</li>
<li>Data science gaining popularity with Big Data emergence</li>
</ul>
<p><strong>Definition</strong>[3]
<strong>Data science</strong> = interdisciplinary field consisting of statistics, computer science, machine learning, and others</p>
<p><strong>Key Value</strong>[3]</p>
<ul>
<li>Help businesses make data-driven decision-making</li>
<li>Apply data collection, preparation, analysis methods</li>
<li>Mine massive data volumes</li>
<li>Understand customer behavior</li>
<li>Explore business opportunities</li>
</ul>
<hr>
<h2 id="-16-2-applications-of-data-science-3-"><strong>16.2 APPLICATIONS OF DATA SCIENCE</strong>[3]</h2>
<p><strong>Main Applications</strong>[3]</p>
<table>
<thead>
<tr>
<th>Application</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Smart Recommendations</strong></td>
<td>Analyze historical data; provide effective recommendations</td>
</tr>
<tr>
<td><strong>Big Data Analytics</strong></td>
<td>Analyze massive data (sensor, IoT, social media, logs) for insights</td>
</tr>
<tr>
<td><strong>Web Search</strong></td>
<td>Analyze web-scale data for accurate search results</td>
</tr>
<tr>
<td><strong>Data Analytics</strong></td>
<td>Analysis and visualization for insights, predictions, forecasting</td>
</tr>
<tr>
<td><strong>Business Intelligence</strong></td>
<td>Identify challenges, cross-sell/upsell, evaluate offers, marketing opportunities</td>
</tr>
<tr>
<td><strong>Healthcare</strong></td>
<td>Wearable-generated data for active monitoring; reduce complications</td>
</tr>
<tr>
<td><strong>Finance</strong></td>
<td>Fraud detection, risk detection, pattern recognition, predictive analytics</td>
</tr>
<tr>
<td><strong>Automobile</strong></td>
<td>Train driverless vehicles; evaluate model performance</td>
</tr>
<tr>
<td><strong>Supply Chain</strong></td>
<td>Forecasting, demand planning, revenue forecasting</td>
</tr>
<tr>
<td><strong>Telecom</strong></td>
<td>Customer churn forecasting</td>
</tr>
</tbody>
</table>
<p><strong>Other Applications</strong>[3]</p>
<ul>
<li>Election campaigning</li>
<li>Chatbots and virtual assistants</li>
<li>Automated cars</li>
<li>Disaster prediction</li>
<li>Product pricing</li>
<li>Preventive maintenance</li>
<li>Customer retention</li>
<li>Pattern recognition</li>
<li>Online advertisement</li>
<li>Demand forecasting</li>
<li>Trend analysis</li>
<li>Campaign effectiveness identification</li>
</ul>
<p><strong>Business Value Dimensions</strong>[3]
âœ“ <strong>Describe</strong> â€” exploratory analysis of events and phenomena
âœ“ <strong>Diagnose</strong> â€” understand why events happened
âœ“ <strong>Predict</strong> â€” forecast what will happen in future
âœ“ <strong>Prescribe</strong> â€” determine actions to make/prevent</p>
<hr>
<h2 id="-16-3-background-of-data-science-3-"><strong>16.3 BACKGROUND OF DATA SCIENCE</strong>[3]</h2>
<p><strong>History</strong>[3]</p>
<ul>
<li>Data analysis existed since 1960s</li>
<li>Term &quot;Data Science&quot; coined in 1974 by Peter Naur</li>
<li>Popularized in 1985 by C.F.Jeff Wu</li>
</ul>
<p><strong>Evolution of Recommendation Methods</strong>[3]</p>
<table>
<thead>
<tr>
<th>Period</th>
<th>Method</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Early 2010</strong></td>
<td>Business Rules</td>
<td>Formal and rigid rules</td>
</tr>
<tr>
<td><strong>2011</strong></td>
<td>Linear Regression</td>
<td>Basic model</td>
</tr>
<tr>
<td><strong>2013</strong></td>
<td>Logistic Regression</td>
<td>Greater accuracy</td>
</tr>
<tr>
<td><strong>2014</strong></td>
<td>Decision Trees</td>
<td>Wide adoption</td>
</tr>
<tr>
<td><strong>2015</strong></td>
<td>Collaborative Filtering</td>
<td>Amazon, Netflix leverage</td>
</tr>
<tr>
<td><strong>2017</strong></td>
<td>Bayesian Network</td>
<td>Network-based approach</td>
</tr>
<tr>
<td><strong>2019+</strong></td>
<td>ML and Deep Learning</td>
<td>Heavy adoption for better accuracy</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-16-4-definition-of-data-science-3-"><strong>16.4 DEFINITION OF DATA SCIENCE</strong>[3]</h2>
<p><strong>Definition</strong>[3]
&quot;Data science is an interdisciplinary field that deals with collecting, analyzing, visualizing data using statistical and machine learning methods to convert raw data into data products.&quot;</p>
<p><strong>Core Goal</strong>[3]</p>
<ul>
<li>Make sense and actionable insights out of raw data</li>
</ul>
<p><strong>Data Science Disciplines</strong>[3]
âœ“ Machine Learning
âœ“ Statistics
âœ“ Analytics
âœ“ Computer Science
âœ“ Big Data
âœ“ Domain expertise (essential)</p>
<hr>
<h2 id="-16-5-data-science-tools-3-"><strong>16.5 DATA SCIENCE TOOLS</strong>[3]</h2>
<p><strong>Tool Categories</strong>[3]</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Tools/Technologies</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AI &amp; ML</strong></td>
<td>TensorFlow, Pytorch, SVM, Supervised/Unsupervised learning</td>
</tr>
<tr>
<td><strong>Big Data</strong></td>
<td>Apache Spark, Apache Hadoop, NoSQL (DynamoDB, MongoDB)</td>
</tr>
<tr>
<td><strong>Statistics</strong></td>
<td>Probability, Vector Algebra, Calculus, Regression</td>
</tr>
<tr>
<td><strong>Data Visualization</strong></td>
<td>Qlik, PowerBI, Tableau</td>
</tr>
<tr>
<td><strong>Platforms</strong></td>
<td>Matlab, IBM Watson Studio, Anaconda, Numpy, Jupyter</td>
</tr>
<tr>
<td><strong>Operations Research</strong></td>
<td>Decision Tree, Decision Modeling</td>
</tr>
<tr>
<td><strong>Programming Languages</strong></td>
<td>R, Python, Scala, Julia, Java, C</td>
</tr>
<tr>
<td><strong>Model Development</strong></td>
<td>Matlab, Octave, MADLib</td>
</tr>
<tr>
<td><strong>Domain Skills</strong></td>
<td>Industry-specific understanding</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-16-5-data-science-and-big-data-3-"><strong>16.5 DATA SCIENCE AND BIG DATA</strong>[3]</h2>
<p><strong>Relationship</strong>[3]</p>
<ul>
<li>Big Data proliferation propelled Data Science popularity</li>
<li>Big Data sources increase in volume, velocity, veracity, variety</li>
<li>Cannot manage through traditional databases</li>
</ul>
<p><strong>Big Data Challenges</strong>[3]</p>
<ul>
<li>Structured, semi-structured, unstructured data</li>
<li>High volume and velocity (massive rate of increase)</li>
<li>Quality and trustworthiness concerns (veracity)</li>
<li>Diverse data types (variety)</li>
</ul>
<p><strong>Big Data Systems</strong>[3]</p>
<ul>
<li>Don&#39;t strictly adhere to ACID (Atomicity, Consistency, Integrity, Durability)</li>
<li>Aim for eventual consistency per CAP theorem</li>
<li>Popular systems: MongoDB, DynamoDB, CouchDB (NoSQL products)</li>
</ul>
<p><strong>Data Science with Big Data</strong>[3]
âœ“ Build, explore, fine-tune models for massive datasets
âœ“ Leverage Big Data management and processing technologies
âœ“ Use Apache Hadoop and NoSQL databases</p>
<hr>
<h2 id="-16-6-phases-of-data-science-process-3-"><strong>16.6 PHASES OF DATA SCIENCE PROCESS</strong>[3]</h2>
<p><strong>Lifecycle Stages</strong>[3]
Raw data undergoes series of analysis and changes through pipeline stages. Process is cyclic with feedback from each stage to previous stage.</p>
<hr>
<h2 id="-16-6-1-requirements-gathering-and-data-discovery-3-"><strong>16.6.1 REQUIREMENTS GATHERING AND DATA DISCOVERY</strong>[3]</h2>
<p><strong>Business Understanding</strong>[3]
âœ“ Understand business requirements, goals, focus areas, challenges
âœ“ Identify key data sources and data inventories
âœ“ Learn existing data analysis tools and technologies
âœ“ Identify Subject Matter Experts (SMEs), sponsors, stakeholders
âœ“ Understand time and budget constraints
âœ“ Review existing data analysis initiatives</p>
<p><strong>Hypothesis Formation</strong>[3]
âœ“ Domain experts and business analysts provide business domain heuristics
âœ“ Formulate initial hypothesis
âœ“ Thoroughly understand business domain
âœ“ Formulate problem for data science methods</p>
<p><strong>Data Collection</strong>[3]
âœ“ Collect data from various sources
âœ“ Examples: data lakes, relational databases, ERP systems, social media, collaboration systems
âœ“ For customer behavioral analysis: CRM system, user profiles, order history, product reviews, emails, social media</p>
<hr>
<h2 id="-16-6-2-data-preparation-stage-3-"><strong>16.6.2 DATA PREPARATION STAGE</strong>[3]</h2>
<p><strong>Purpose</strong>[3]</p>
<ul>
<li>Improve quality of extracted data</li>
<li>Cleanse data to standardize format and structure</li>
</ul>
<p><strong>Main Activities</strong>[3]
âœ“ Remove duplicates
âœ“ Bring to common/standard format
âœ“ Infer missing values
âœ“ Smooth data by removing noise
âœ“ Filter and sample data
âœ“ Make data types consistent
âœ“ Replace missing values with mean/median</p>
<p><strong>ETL Tools</strong>[3]</p>
<ul>
<li>Data conditioning can be performed by Extract, Transform, Load (ETL) tools</li>
<li>Data normalization and case conversion</li>
</ul>
<p><strong>Data Scientists&#39; Role</strong>[3]</p>
<ul>
<li>&quot;Separate signal from noise&quot;</li>
</ul>
<hr>
<h2 id="-16-6-3-data-exploration-stage-3-"><strong>16.6.3 DATA EXPLORATION STAGE</strong>[3]</h2>
<p><strong>Activities</strong>[3]
âœ“ Extract features from data
âœ“ Process data
âœ“ Perform first-cut analysis
âœ“ Form initial hypothesis
âœ“ Classify and cluster data into logical categories
âœ“ Identify relationships between variables
âœ“ Select key predictors essential for prediction</p>
<p><strong>Example: Used Car Price Prediction</strong>[3]</p>
<ul>
<li>Examine massive historical car sales transactions</li>
<li>Identify key features: car mileage, age, kms driven, engine capacity, purchase price</li>
<li>These directly correlate with market price</li>
<li>Hypothesis: &quot;Car age inversely correlated to final price&quot;</li>
</ul>
<hr>
<h2 id="-16-6-4-model-development-and-prediction-stage-3-"><strong>16.6.4 MODEL DEVELOPMENT AND PREDICTION STAGE</strong>[3]</h2>
<p><strong>Activities</strong>[3]
âœ“ Design and develop machine learning models
âœ“ Train and fine-tune models iteratively
âœ“ Test model performance
âœ“ Evaluate various models on selected data</p>
<p><strong>Statistical Methods Used</strong>[3]</p>
<ul>
<li>Regression analysis</li>
<li>Qualitative methods</li>
<li>Decision tree models</li>
<li>Deep learning models</li>
</ul>
<p><strong>Model Evaluation</strong>[3]
âœ“ Accuracy of model prediction
âœ“ Performance on various training/test datasets</p>
<p><strong>Final Step</strong>[3]</p>
<ul>
<li>Use selected model for prediction</li>
</ul>
<hr>
<h2 id="-16-6-5-data-visualization-stage-3-"><strong>16.6.5 DATA VISUALIZATION STAGE</strong>[3]</h2>
<p><strong>Purpose</strong>[3]</p>
<ul>
<li>Visually communicate obtained insights</li>
<li>Help audience make informed decisions</li>
</ul>
<p><strong>Tools and Methods</strong>[3]
âœ“ Reports
âœ“ Business Intelligence (BI) tools
âœ“ Charts and infographics
âœ“ Visual representations</p>
<p><strong>Post-Implementation</strong>[3]
âœ“ Operationalize model for business prediction
âœ“ Continuously fine-tune based on feedback
âœ“ Learn from real-world data</p>
<hr>
<h2 id="-16-7-data-science-methods-3-"><strong>16.7 DATA SCIENCE METHODS</strong>[3]</h2>
<p><strong>16.7.1 CLUSTERING METHOD</strong>[3]</p>
<p><strong>Definition</strong>[3]</p>
<ul>
<li>Group objects into logical clusters based on object attributes</li>
<li>Unsupervised learning â€” model groups data based on labels</li>
</ul>
<p><strong>Example Age Groups</strong>[3]</p>
<ul>
<li>Users less than 20 years</li>
<li>Users between 20-40 years</li>
<li>Users more than 40 years</li>
</ul>
<p><strong>Main Clustering Methods</strong>[3]</p>
<ul>
<li>Hierarchical clustering</li>
<li>Fuzzy clustering</li>
<li>K-means clustering</li>
<li>Nearest neighboring</li>
</ul>
<p><strong>Use Cases</strong>[3]
âœ“ Group-based personalization
âœ“ Customer segmentation
âœ“ Image processing</p>
<hr>
<h2 id="-16-7-2-collaborative-filtering-similarity-matching-3-"><strong>16.7.2 COLLABORATIVE FILTERING/SIMILARITY MATCHING</strong>[3]</h2>
<p><strong>Definition</strong>[3]</p>
<ul>
<li>Identify users with similar interests based on likes/purchases</li>
<li>Use information for recommending new products</li>
</ul>
<p><strong>How It Works</strong>[3]</p>
<ul>
<li>Set of rules to understand similarity between users, products, information sources</li>
<li>If User A and User B have same interests, recommend User A&#39;s purchases to User B</li>
</ul>
<p><strong>Variation: Co-occurrence Grouping</strong>[3]</p>
<ul>
<li>Understand association of products (often purchased together)</li>
<li>Recommend closely related products to customer</li>
</ul>
<p><strong>Recommendation Examples</strong>[3]
âœ“ &quot;Customers who bought this item also bought these items&quot;
âœ“ &quot;Based on your purchase history, we recommend these products&quot;
âœ“ &quot;You may also like these products&quot;</p>
<p><strong>Use Cases</strong>[3]
âœ“ Cross-sell and up-sell opportunities
âœ“ Campaigns and product promotions
âœ“ Product offers</p>
<hr>
<h2 id="-16-7-3-regression-methods-3-"><strong>16.7.3 REGRESSION METHODS</strong>[3]</h2>
<p><strong>Definition</strong>[3]</p>
<ul>
<li>Identify relationship (as function) between dependent and independent variables</li>
<li>Predict independent variable using key predictor dependent variables</li>
</ul>
<p><strong>Example: House Price Prediction</strong>[3]</p>
<ul>
<li>Get historical house sales data from past 5 years</li>
<li>Use logistic regression between independent variable (house price) and dependent variables</li>
<li>Dependent variables: number of beds, location, carpet area, amenities, nearby points of interest</li>
</ul>
<p><strong>Use Cases</strong>[3]
âœ“ Prediction and forecasting scenarios
âœ“ Demand forecasting
âœ“ Price prediction
âœ“ Probability of event prediction (customer churn, loan default)</p>
<hr>
<h2 id="-16-7-4-classification-methods-3-"><strong>16.7.4 CLASSIFICATION METHODS</strong>[3]</h2>
<p><strong>Definition</strong>[3]</p>
<ul>
<li>Supervised learning using labelled data</li>
<li>Once trained, classifier labels new data</li>
</ul>
<p><strong>Main Classification Methods</strong>[3]</p>
<ul>
<li>Decision tree method</li>
<li>NaÃ¯ve Bayes classification</li>
<li>Confusion matrix</li>
</ul>
<p><strong>Decision Tree Method</strong>[3]</p>
<ul>
<li>Structure decisions in tree format</li>
<li>Test points (nodes) with Boolean values (yes/no) as branches</li>
<li>Traverse path to reach predicted value</li>
</ul>
<p><strong>Use Cases</strong>[3]
âœ“ Prediction scenarios
âœ“ Recommendation scenarios</p>
<hr>
<h2 id="-16-7-5-other-methods-3-"><strong>16.7.5 OTHER METHODS</strong>[3]</h2>
<table>
<thead>
<tr>
<th>Method</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Time Series Prediction</strong></td>
<td>Analyze events at regular time intervals</td>
</tr>
<tr>
<td><strong>Text Analysis</strong></td>
<td>Gain insights from text using bag of words, TFIDF, topic modeling</td>
</tr>
<tr>
<td><strong>Sentiment Analysis</strong></td>
<td>Analyze sentiment from text</td>
</tr>
<tr>
<td><strong>Profiling</strong></td>
<td>Characterize event, user, or object</td>
</tr>
<tr>
<td><strong>Reduction</strong></td>
<td>Reduce large dataset into smaller representative dataset</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="-16-8-case-study-product-purchase-probability-prediction-3-"><strong>16.8 CASE STUDY: PRODUCT PURCHASE PROBABILITY PREDICTION</strong>[3]</h2>
<p><strong>Objective</strong>[3]</p>
<ul>
<li>Understand key features influencing product purchase probability</li>
<li>Develop prediction model given feature values</li>
</ul>
<p><strong>Features Used</strong>[3]</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Age_LT30</strong></td>
<td>Buyer aged below 30 years (1=Yes, 0=No)</td>
</tr>
<tr>
<td><strong>Age_GT30</strong></td>
<td>Buyer aged above 30 years (1=Yes, 0=No)</td>
</tr>
<tr>
<td><strong>In_LT50</strong></td>
<td>Monthly income less than 50K (1=Yes, 0=No)</td>
</tr>
<tr>
<td><strong>In_GT50</strong></td>
<td>Monthly income greater than 50K (1=Yes, 0=No)</td>
</tr>
<tr>
<td><strong>Loyal_CT</strong></td>
<td>Enrolled in loyalty program (1=Yes, 0=No)</td>
</tr>
<tr>
<td><strong>onSale</strong></td>
<td>Product on sale (1=Yes, 0=No)</td>
</tr>
<tr>
<td><strong>Prod_buy</strong></td>
<td>Product purchased (1=Yes, 0=No) â€” target variable</td>
</tr>
</tbody>
</table>
<p><strong>Data Collection</strong>[3]</p>
<ul>
<li>11 historical transaction examples collected</li>
</ul>
<p><strong>Data Cleansing Stage</strong>[3]</p>
<ul>
<li>Fix data entry errors</li>
<li>Handle missing data (use median or drop if missing in both sets)</li>
<li>Code values appropriately (&quot;Yes&quot; â†’ &quot;1&quot;, &quot;Nil&quot; â†’ &quot;0&quot;)</li>
<li>Discard incomplete rows</li>
</ul>
<p><strong>Data Exploration Insights</strong>[3]
âœ“ Feature Age_GT30 positively and linearly correlated to prod_buy
âœ“ Feature Age_LT30 inversely related to prod_buy
âœ“ Feature In_GT50 positively and linearly correlated to prod_buy
âœ“ Feature In_LT50 inversely related to prod_buy
âœ“ Loyal_CT and onSale positively correlated to prod_buy</p>
<p><strong>Model Selection</strong>[3]</p>
<ul>
<li>Decision tree model selected for factors incorporating all key features</li>
<li>Visualize combination and impact of various features</li>
<li>Validate with test data for accurate predictions</li>
</ul>
<p><strong>Prediction Models Evaluated</strong>[3]</p>
<ul>
<li>Gaussian Naive Bayes</li>
<li>Logistic Regression</li>
<li>Support Vector Machines</li>
<li>Perceptron</li>
<li>Decision Tree Classifier</li>
<li>Random Forest Classifier</li>
<li>KNN (k-Nearest Neighbors)</li>
<li>Stochastic Gradient Descent</li>
<li>Gradient Boosting Classifier</li>
</ul>
<hr>
<h2 id="-16-9-summary-3-"><strong>16.9 SUMMARY</strong>[3]</h2>
<p><strong>Key Concepts Covered</strong>[3]
âœ“ Main applications of data science
âœ“ Interdisciplinary nature (computer science, big data, statistics, analytics, machine learning)
âœ“ Key data science tools (R, Python, Matlab)
âœ“ Relationship between data science and Big Data
âœ“ Data science lifecycle phases</p>
<p><strong>Lifecycle Phases Summary</strong>[3]</p>
<ul>
<li>Requirements gathering: gather all data sources</li>
<li>Data preparation: condition and fix errors</li>
<li>Data exploration: examine key features and build hypothesis</li>
<li>Prediction: build models for prediction</li>
<li>Data visualization: document findings and showcase</li>
</ul>
<p><strong>Methods Covered</strong>[3]
âœ“ Clustering
âœ“ Collaborative filtering
âœ“ Regression
âœ“ Classification</p>
<p><strong>Case Study Completion</strong>[3]</p>
<ul>
<li>Detailed walkthrough: predicting product purchase probability using decision trees</li>
</ul>
<hr>

</body>
 <footer class="container">
  <hr>
  <small>
    <strong>IGNOU MCA Course Notes</strong> â€” MCS213 Software Engineering  
    <br>
    Free study material for IGNOU MCA students Â· Easy explanations Â· Exam-focused  
    <br>
    <em>Not an official IGNOU website</em>
  </small>
</footer>

</html>

